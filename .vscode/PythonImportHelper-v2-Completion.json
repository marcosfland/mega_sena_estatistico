[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "cx_Freeze",
        "description": "cx_Freeze",
        "isExtraImport": true,
        "detail": "cx_Freeze",
        "documentation": {}
    },
    {
        "label": "Executable",
        "importPath": "cx_Freeze",
        "description": "cx_Freeze",
        "isExtraImport": true,
        "detail": "cx_Freeze",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Menu",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_period",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_weighted",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "monte_carlo_simulation",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "plot_frequency",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_time_series",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_probability_distribution",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "update_db",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_pairs",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_triplets",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "conditional_probability",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "filter_draws_by_period",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "sanitize_filename",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "save_user_set",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_user_sets",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_with_latest_draw",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_backtest",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_backtest_summary",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "NUM_DEZENAS",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "MAX_NUM_MEGA_SENA",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "combinations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "get_git_version",
        "kind": 2,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "def get_git_version():\n    \"\"\"Obt√©m vers√£o do Git se dispon√≠vel\"\"\"\n    try:\n        # Tenta obter a tag mais recente\n        result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], \n                              capture_output=True, text=True, cwd=os.path.dirname(__file__))\n        if result.returncode == 0:\n            return result.stdout.strip()\n    except:\n        pass",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "get_build_info",
        "kind": 2,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "def get_build_info():\n    \"\"\"Obt√©m informa√ß√µes de build\"\"\"\n    try:\n        # Hash do commit atual\n        result = subprocess.run(['git', 'rev-parse', '--short', 'HEAD'], \n                              capture_output=True, text=True)\n        if result.returncode == 0:\n            commit_hash = result.stdout.strip()\n            return f\"build-{commit_hash}\"\n    except:",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "VERSION = get_git_version()\nBUILD_INFO = get_build_info()\nFULL_VERSION = f\"{VERSION}-{BUILD_INFO}\"\nprint(f\"üî® Vers√£o detectada: {FULL_VERSION}\")\n# Nome do arquivo principal do seu projeto\nmain_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "BUILD_INFO",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "BUILD_INFO = get_build_info()\nFULL_VERSION = f\"{VERSION}-{BUILD_INFO}\"\nprint(f\"üî® Vers√£o detectada: {FULL_VERSION}\")\n# Nome do arquivo principal do seu projeto\nmain_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "FULL_VERSION",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "FULL_VERSION = f\"{VERSION}-{BUILD_INFO}\"\nprint(f\"üî® Vers√£o detectada: {FULL_VERSION}\")\n# Nome do arquivo principal do seu projeto\nmain_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []\n}",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "main_script",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "main_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []\n}\n# Informa√ß√µes do execut√°vel\nsetup(\n    name=\"MegaSenaEstatistico\",",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "build_exe_options",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "build_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []\n}\n# Informa√ß√µes do execut√°vel\nsetup(\n    name=\"MegaSenaEstatistico\",\n    version=\"1.0\",\n    description=\"Ferramenta estat√≠stica para Mega Sena\",",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "show_message",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_message(title, message, is_error=False):\n    if status_bar:\n        status_bar.config(text=message)\n    if is_error:\n        logging.error(f\"{title}: {message}\")\n        messagebox.showerror(title, message)\n    else:\n        logging.info(f\"{title}: {message}\")\n        messagebox.showinfo(title, message)\n    if root and status_bar:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "open_file_location",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def open_file_location(filepath):\n    try:\n        folder = os.path.dirname(os.path.abspath(filepath))\n        if os.name == 'nt':\n            os.startfile(folder)\n        elif os.name == 'posix':\n            subprocess.Popen(['xdg-open', folder])\n        show_message(\"Local Aberto\", f\"A pasta de '{filepath}' foi aberta.\", False)\n    except Exception as e:\n        show_message(\"Erro\", f\"N√£o foi poss√≠vel abrir o local do arquivo: {e}\", True)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "run_in_thread",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_in_thread(func, *args, **kwargs):\n    if status_bar:\n        status_bar.config(text=\"Processando... Por favor, aguarde.\")\n    thread = threading.Thread(target=lambda: func(*args, **kwargs))\n    thread.start()\ndef run_analysis_gui(option):\n    def _run():\n        try:\n            draws = load_all_draws()\n            if not draws:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "run_analysis_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_analysis_gui(option):\n    def _run():\n        try:\n            draws = load_all_draws()\n            if not draws:\n                show_message(\"Erro\", \"Base de dados vazia. Execute a atualiza√ß√£o primeiro.\", True)\n                return\n            result_message = \"\"\n            plot_needed = False\n            if option == \"alltime\":",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "export_data_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def export_data_gui(advanced=False):\n    def _export():\n        try:\n            draws = load_all_draws()\n            if not draws:\n                show_message(\"Erro\", \"Base de dados vazia. Execute a atualiza√ß√£o primeiro.\", True)\n                return\n            if advanced:\n                tipo = simpledialog.askstring(\"Exporta√ß√£o Avan√ßada\", \"Tipo de an√°lise (frequencia, pares, trios, correlacao):\", parent=root)\n                if not tipo: return",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "update_db_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def update_db_gui():\n    def _update():\n        try:\n            update_db()\n            show_message(\"Atualiza√ß√£o\", \"Base de dados atualizada com sucesso!\", False)\n        except Exception as e:\n            show_message(\"Erro na Atualiza√ß√£o\", f\"Ocorreu um erro ao atualizar a base de dados: {e}\", True)\n    run_in_thread(_update)\ndef generate_and_save_user_set_gui():\n    def _generate_and_save():",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "generate_and_save_user_set_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def generate_and_save_user_set_gui():\n    def _generate_and_save():\n        draws = load_all_draws()\n        if not draws:\n            show_message(\"Erro\", \"Base de dados vazia. Atualize primeiro para gerar n√∫meros.\", True)\n            return\n        method = simpledialog.askstring(\"Gerar Meus N√∫meros\", \"Escolha o m√©todo (alltime, lastyear, weighted):\", parent=root)\n        if not method: return\n        generated_numbers: Optional[List[int]] = []\n        if method == \"alltime\":",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def compare_user_sets_gui():\n    def _compare():\n        user_sets = load_user_sets()\n        if not user_sets:\n            show_message(\"Erro\", \"Nenhum conjunto de n√∫meros salvo para compara√ß√£o.\", True)\n            return\n        comparison_results = compare_user_sets_with_latest_draw()\n        if not comparison_results:\n            show_message(\"Erro\", \"N√£o foi poss√≠vel realizar a compara√ß√£o. Verifique a base de dados da Mega-Sena e a conex√£o com a API.\", True)\n            return",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "toggle_compare_button_state",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def toggle_compare_button_state():\n    global compare_button\n    if compare_button is not None:\n        user_sets = load_user_sets()\n        if user_sets:\n            compare_button.config(state=tk.NORMAL)\n        else:\n            compare_button.config(state=tk.DISABLED)\ndef run_backtest_gui(method: Optional[str] = None):\n    \"\"\"Permite ao usu√°rio escolher um m√©todo e executa o backtest.\"\"\"",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "run_backtest_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_backtest_gui(method: Optional[str] = None):\n    \"\"\"Permite ao usu√°rio escolher um m√©todo e executa o backtest.\"\"\"\n    def _prompt_and_run():\n        if not method:\n            selected_method = simpledialog.askstring(\"Executar Backtest\", \"Escolha o m√©todo (alltime, lastyear, weighted):\", parent=root)\n            if not selected_method:\n                return\n        else:\n            selected_method = method\n        show_message(\"Backtest\", f\"Iniciando backtest para o m√©todo '{selected_method}'...\", False)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_backtest_results_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_backtest_results_gui(method: str):\n    \"\"\"Exibe os resultados do backtest em uma janela.\"\"\"\n    summary = get_backtest_summary(method)\n    if not summary['numbers']:\n        show_message(\"Erro\", f\"Nenhum resultado de backtest encontrado para o m√©todo '{method}'.\", True)\n        return\n    result_text = f\"Backtest para o m√©todo: '{summary['method']}'\\n\"\n    result_text += f\"N√∫meros gerados: {summary['numbers']}\\n\\n\"\n    result_text += f\"Resultado contra {summary['total_draws']} sorteios hist√≥ricos:\\n\"\n    # Calculate total matches",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_help",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_help():\n    help_text = \"\"\"\n    **Mega-Sena Analyzer GUI**\n    - **Atualizar Base de Dados**: Busca os √∫ltimos resultados da Mega-Sena e os armazena localmente.\n    - **Top 6 de Todos os Tempos**: Mostra os n√∫meros sorteados com maior frequ√™ncia em todo o hist√≥rico.\n    - **Top 6 do √öltimo Ano**: Identifica os n√∫meros mais frequentes nos √∫ltimos 365 dias.\n    - **Conjunto Estat√≠stico Ponderado**: Sugere um conjunto de 6 n√∫meros baseado na frequ√™ncia hist√≥rica, dando mais peso aos n√∫meros mais sorteados.\n    - **Visualizar Frequ√™ncia**: Abre um gr√°fico de barras mostrando a frequ√™ncia de cada n√∫mero (1 a 60).\n    - **Simula√ß√£o de Monte Carlo**: Simula milhares de sorteios aleat√≥rios para comparar as frequ√™ncias simuladas com as reais.\n    - **Correla√ß√£o**: Calcula a matriz de correla√ß√£o entre os n√∫meros, indicando quais n√∫meros tendem a sair juntos (para exporta√ß√£o avan√ßada).",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "open_github",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def open_github():\n    webbrowser.open(\"https://github.com/marcosfland/mega_sena_estatistico\")\n    show_message(\"Informa√ß√£o\", \"Reposit√≥rio do GitHub aberto no navegador.\", False)\ndef show_about():\n    about_text = \"Mega-Sena Analyzer\\nVers√£o 1.3 (Backtest de Estrat√©gias)\\nDesenvolvido por Marcos\\n\\nFerramenta de an√°lise estat√≠stica para os sorteios da Mega-Sena.\"\n    messagebox.showinfo(\"Sobre o Mega-Sena Analyzer\", about_text)\ndef create_gui():\n    global root, status_bar, compare_button\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_about",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_about():\n    about_text = \"Mega-Sena Analyzer\\nVers√£o 1.3 (Backtest de Estrat√©gias)\\nDesenvolvido por Marcos\\n\\nFerramenta de an√°lise estat√≠stica para os sorteios da Mega-Sena.\"\n    messagebox.showinfo(\"Sobre o Mega-Sena Analyzer\", about_text)\ndef create_gui():\n    global root, status_bar, compare_button\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")\n    root.geometry(\"650x900\") # Aumentado um pouco para acomodar o novo frame\n    root.resizable(False, False)\n    icon_path = get_resource_path(\"icon.png\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "create_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def create_gui():\n    global root, status_bar, compare_button\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")\n    root.geometry(\"650x900\") # Aumentado um pouco para acomodar o novo frame\n    root.resizable(False, False)\n    icon_path = get_resource_path(\"icon.png\")\n    if os.path.exists(icon_path) and Image:\n        try:\n            icon_image = tk.PhotoImage(file=icon_path)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "get_resource_path",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def get_resource_path(relative_path):\n    base_path = getattr(sys, '_MEIPASS', os.path.abspath(os.path.dirname(__file__)))\n    return os.path.join(base_path, relative_path)\nif __name__ == \"__main__\":\n    if not os.path.exists(get_resource_path(\"icon.png\")):\n        try:\n            if Image and ImageDraw:\n                img = Image.new('RGBA', (32, 32), (0, 0, 0, 0))\n                draw = ImageDraw.Draw(img)\n                draw.ellipse((2, 2, 30, 30), fill='#FFD700', outline='#DAA520')",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "root = None\nstatus_bar = None\ncompare_button = None\ndef show_message(title, message, is_error=False):\n    if status_bar:\n        status_bar.config(text=message)\n    if is_error:\n        logging.error(f\"{title}: {message}\")\n        messagebox.showerror(title, message)\n    else:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "status_bar",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "status_bar = None\ncompare_button = None\ndef show_message(title, message, is_error=False):\n    if status_bar:\n        status_bar.config(text=message)\n    if is_error:\n        logging.error(f\"{title}: {message}\")\n        messagebox.showerror(title, message)\n    else:\n        logging.info(f\"{title}: {message}\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "compare_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "compare_button = None\ndef show_message(title, message, is_error=False):\n    if status_bar:\n        status_bar.config(text=message)\n    if is_error:\n        logging.error(f\"{title}: {message}\")\n        messagebox.showerror(title, message)\n    else:\n        logging.info(f\"{title}: {message}\")\n        messagebox.showinfo(title, message)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite, criando a tabela megasena se n√£o existir.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS megasena (",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_last_db_concurso",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_last_db_concurso(path: str = DB_PATH) -> int:\n    \"\"\"\n    Retorna o n√∫mero do √∫ltimo concurso registrado no banco de dados.\n    Retorna 0 se o banco de dados estiver vazio ou houver um erro.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute('SELECT MAX(concurso) FROM megasena')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "fetch_lottery_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def fetch_lottery_data(lottery: str = \"megasena\", concurso: Optional[int] = None) -> Dict[str, Any]:\n    \"\"\"\n    Busca dados de um concurso espec√≠fico de uma loteria na API.\n    Se 'concurso' for None, busca o √∫ltimo resultado.\n    \"\"\"\n    if lottery not in API_LOTERIAS:\n        raise ValueError(f\"Loteria '{lottery}' n√£o suportada.\")\n    url: str = f\"{API_LOTERIAS[lottery]}/{concurso}\" if concurso else f\"{API_LOTERIAS[lottery]}/latest\"\n    try:\n        resp: requests.Response = requests.get(url)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "validate_api_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def validate_api_data(data: Dict[str, Any], lottery: str) -> bool:\n    \"\"\"\n    Valida os dados retornados pela API para a loteria especificada.\n    \"\"\"\n    if lottery == \"megasena\":\n        required_keys = {'concurso', 'data', 'dezenas'}\n        if not all(key in data for key in required_keys):\n            logging.warning(f\"Dados da API para Mega-Sena faltando chaves esperadas: {data.keys()}\")\n            return False\n        if not isinstance(data['dezenas'], list) or len(data['dezenas']) != NUM_DEZENAS:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "update_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def update_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Atualiza a base de dados local com os resultados mais recentes da Mega-Sena.\n    \"\"\"\n    init_db(path)\n    ultimo_db: int = get_last_db_concurso(path)\n    ultimo_api: int = 0\n    try:\n        data_last: Dict[str, Any] = fetch_lottery_data(\"megasena\", None)\n        ultimo_api = int(data_last['concurso'])",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def load_all_draws(path: str = DB_PATH) -> List[Draw]:\n    \"\"\"\n    Carrega todos os sorteios da Mega-Sena do banco de dados.\n    Retorna uma lista de tuplas (data, dezenas).\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    draws: List[Draw] = []\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent(draws: List[Draw], k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Calcula os k n√∫meros mais frequentes em todos os sorteios.\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    return [num for num, _ in counter.most_common(k)]\ndef get_most_frequent_period(draws: List[Draw], days: int = 365, k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_period",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_period(draws: List[Draw], days: int = 365, k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Calcula os k n√∫meros mais frequentes em um per√≠odo espec√≠fico (em dias).\n    \"\"\"\n    today = datetime.date.today()\n    cutoff = today - datetime.timedelta(days=days)\n    filtered = [(d, nums) for d, nums in draws if d >= cutoff]\n    if not filtered:\n        logging.warning(f\"Nenhum sorteio encontrado nos √∫ltimos {days} dias.\")\n        return []",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_weighted",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_weighted(draws: List[Draw], k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Gera um conjunto de n√∫meros ponderado pela frequ√™ncia hist√≥rica.\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    all_nums: List[int] = list(range(1, MAX_NUM_MEGA_SENA + 1))\n    weights: List[int] = [counter[n] for n in all_nums]\n    if sum(weights) == 0:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "plot_frequency",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def plot_frequency(draws: List[Draw]) -> None:\n    \"\"\"\n    Gera um gr√°fico de barras da frequ√™ncia de cada n√∫mero sorteado.\n    \"\"\"\n    if not plt:\n        logging.error(\"Matplotlib n√£o est√° instalado. N√£o √© poss√≠vel gerar o gr√°fico de frequ√™ncia.\")\n        return\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "monte_carlo_simulation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def monte_carlo_simulation(draws: List[Draw], simulations: int = 10000) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:\n    \"\"\"\n    Realiza uma simula√ß√£o de Monte Carlo para comparar frequ√™ncias simuladas com as reais.\n    Retorna os 6 n√∫meros mais frequentes simulados e reais.\n    \"\"\"\n    if not np:\n        logging.error(\"NumPy n√£o est√° instalado. N√£o √© poss√≠vel realizar a simula√ß√£o de Monte Carlo.\")\n        return [], []\n    all_nums: List[int] = list(range(1, MAX_NUM_MEGA_SENA + 1))\n    simulated_counts: Counter = Counter()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def calculate_correlation(draws: List[Draw]) -> Optional[Any]:\n    \"\"\"\n    Calcula a matriz de correla√ß√£o entre os n√∫meros sorteados.\n    \"\"\"\n    if pd is None:\n        logging.error(\"Pandas n√£o est√° instalado. N√£o √© poss√≠vel calcular a correla√ß√£o.\")\n        return None\n    data: List[List[int]] = []\n    for _, nums in draws:\n        # Create a binary array for each draw: 1 if number is present, 0 otherwise",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_probability_distribution",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_probability_distribution(draws: List[Draw]) -> Optional[Tuple[float, float]]:\n    \"\"\"\n    Analisa a distribui√ß√£o de probabilidade dos n√∫meros sorteados usando o teste Qui-quadrado.\n    Compara a frequ√™ncia observada com uma distribui√ß√£o uniforme esperada.\n    \"\"\"\n    if not chisquare:\n        logging.error(\"SciPy n√£o est√° instalado. N√£o √© poss√≠vel realizar a an√°lise de distribui√ß√£o de probabilidade.\")\n        return None\n    counter: Counter = Counter()\n    for _, nums in draws:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_time_series",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_time_series(draws: List[Draw]) -> None:\n    \"\"\"\n    Analisa a s√©rie temporal dos sorteios, mostrando a frequ√™ncia de sorteios ao longo do tempo.\n    \"\"\"\n    if not plt:\n        logging.error(\"Matplotlib n√£o est√° instalado. N√£o √© poss√≠vel gerar o gr√°fico de s√©ries temporais.\")\n        return\n    # Extract dates and count occurrences for each date\n    date_counts: Counter = Counter(d for d, _ in draws)\n    # Sort dates and get corresponding counts",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "sanitize_filename",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    Sanitiza um nome de arquivo para evitar path traversal e caracteres inv√°lidos.\n    Permite apenas letras, n√∫meros, underline, h√≠fen, ponto e espa√ßo.\n    \"\"\"\n    # Remove leading/trailing whitespace\n    filename = filename.strip()\n    # Replace any sequence of invalid characters with an underscore\n    filename = re.sub(r'[^\\w\\-. ]', '_', filename)\n    # Ensure it's not empty after sanitization",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def export_results(data: List[Tuple[Any, Any]], file_format: str = \"csv\", filename: str = \"results\", header: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Exporta resultados para CSV ou JSON.\n    √â uma fun√ß√£o mais gen√©rica para a exporta√ß√£o de listas de tuplas/listas.\n    \"\"\"\n    full_filename: Optional[str] = None\n    try:\n        filename = sanitize_filename(filename)\n        full_filename = f\"{filename}.{file_format}\"\n        if file_format == \"csv\":",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "schedule_task_crossplatform",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def schedule_task_crossplatform() -> None:\n    \"\"\"\n    Agenda a atualiza√ß√£o di√°ria do banco de dados de forma multiplataforma.\n    Usa `schtasks` no Windows e fornece instru√ß√£o para `crontab` em Linux/macOS.\n    \"\"\"\n    import platform\n    task_name: str = \"MegaSenaUpdate\"\n    script_path: str = os.path.abspath(__file__)\n    if platform.system() == \"Windows\":\n        command: str = f\"schtasks /create /tn \\\"{task_name}\\\" /tr \\\"cmd /c python {script_path} --update\\\" /sc daily /st 12:00 /F\"",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "connect_external_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def connect_external_db(conn_str: str) -> Optional[sqlite3.Connection]:\n    \"\"\"\n    Conecta-se a um banco de dados externo (exemplo para SQLite).\n    Pode ser adaptado para outros tipos de banco de dados (PostgreSQL, MySQL, etc.)\n    requerendo as bibliotecas apropriadas (e.g., psycopg2, mysql-connector-python).\n    \"\"\"\n    logging.info(f\"Tentando conectar ao banco de dados externo com: {conn_str}\")\n    try:\n        # For SQLite, conn_str is typically the path to the database file\n        conn = sqlite3.connect(conn_str)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "filter_draws_by_period",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def filter_draws_by_period(draws: List[Draw], start_date: Optional[datetime.date] = None, end_date: Optional[datetime.date] = None) -> List[Draw]:\n    \"\"\"\n    Filtra os sorteios por um per√≠odo de datas.\n    \"\"\"\n    if not start_date and not end_date:\n        return draws\n    filtered_draws: List[Draw] = []\n    for d, nums in draws:\n        if start_date and d < start_date:\n            continue",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_pairs",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_pairs(draws: List[Draw], k: int = NUM_DEZENAS) -> List[Tuple[Tuple[int, int], int]]:\n    \"\"\"\n    Calcula os k pares de n√∫meros mais frequentes em todos os sorteios.\n    Retorna uma lista de tuplas (par, frequ√™ncia).\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        # Ensure numbers are sorted within the tuple for consistent counting\n        for pair in combinations(sorted(nums), 2):\n            counter[pair] += 1",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_triplets",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_triplets(draws: List[Draw], k: int = NUM_DEZENAS) -> List[Tuple[Tuple[int, int, int], int]]:\n    \"\"\"\n    Calcula os k trios de n√∫meros mais frequentes em todos os sorteios.\n    Retorna uma lista de tuplas (trio, frequ√™ncia).\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        # Ensure numbers are sorted within the tuple for consistent counting\n        for triplet in combinations(sorted(nums), 3):\n            counter[triplet] += 1",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "conditional_probability",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def conditional_probability(draws: List[Draw], given: int, target: int) -> float:\n    \"\"\"\n    Calcula a probabilidade condicional de 'target' ser sorteado, dado que 'given' foi sorteado.\n    P(Target | Given) = P(Target e Given) / P(Given)\n    \"\"\"\n    if not (1 <= given <= MAX_NUM_MEGA_SENA) or not (1 <= target <= MAX_NUM_MEGA_SENA):\n        logging.error(f\"N√∫meros 'given' ({given}) e/ou 'target' ({target}) fora do intervalo v√°lido (1-{MAX_NUM_MEGA_SENA}).\")\n        return 0.0\n    if given == target:\n        logging.warning(\"Probabilidade condicional de um n√∫mero dado ele mesmo √© 1.0 (se ele j√° saiu).\")",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_web_interface",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def run_web_interface(draws: List[Draw]) -> None:\n    \"\"\"\n    Inicia uma interface web Flask para exibir estat√≠sticas.\n    \"\"\"\n    if not Flask:\n        logging.error(\"Flask n√£o est√° instalado. N√£o √© poss√≠vel iniciar a interface web.\")\n        return\n    app = Flask(__name__)\n    @app.route(\"/frequencia\")\n    def frequencia():",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "init_user_sets_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_user_sets_db(path: str = USER_SETS_DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite para os conjuntos de n√∫meros do usu√°rio.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS user_sets (",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "save_user_set",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def save_user_set(name: str, numbers: List[int], path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Salva um conjunto de 6 n√∫meros gerados pelo usu√°rio na base de dados.\n    \"\"\"\n    init_user_sets_db(path)\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        if len(numbers) != NUM_DEZENAS:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_user_sets",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def load_user_sets(path: str = USER_SETS_DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Carrega todos os conjuntos de n√∫meros salvos pelo usu√°rio.\n    \"\"\"\n    init_user_sets_db(path)\n    conn: Optional[sqlite3.Connection] = None\n    user_sets: List[Dict[str, Any]] = []\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "delete_user_set",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def delete_user_set(set_id: int, path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Deleta um conjunto de n√∫meros do usu√°rio pelo ID.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute(\"DELETE FROM user_sets WHERE id = ?\", (set_id,))\n        conn.commit()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_with_latest_draw",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def compare_user_sets_with_latest_draw(user_sets_path: str = USER_SETS_DB_PATH, mega_sena_db_path: str = DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Compara todos os conjuntos de n√∫meros do usu√°rio com o √∫ltimo sorteio da Mega-Sena.\n    \"\"\"\n    latest_draw_data: Optional[Dict[str, Any]] = None\n    try:\n        latest_draw_api = fetch_lottery_data(\"megasena\", None)\n        latest_draw_data = {\n            'concurso': int(latest_draw_api['concurso']),\n            'dezenas': sorted(list(map(int, latest_draw_api['dezenas'])))",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "init_backtest_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_backtest_db(path: str = BACKTEST_DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados para armazenar os resultados do backtest,\n    criando a tabela 'backtest_results' se n√£o existir.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute('''",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_backtest",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def run_backtest(method: str) -> bool:\n    \"\"\"\n    Executa o backtest para um m√©todo de gera√ß√£o de n√∫meros e salva os resultados.\n    \"\"\"\n    init_backtest_db()\n    draws = load_all_draws()\n    if not draws:\n        logging.error('Base de dados vazia para backtest. Execute --update primeiro.')\n        return False\n    generated_numbers: Optional[List[int]] = []",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_backtest_summary",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_backtest_summary(method: str) -> Dict[str, Any]:\n    \"\"\"\n    Carrega os resultados do backtest para um m√©todo e retorna um resumo.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    summary = {\n        'method': method,\n        'numbers': [],\n        'total_draws': 0,\n        'matches': Counter()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description='Mega-Sena Analyzer')\n    parser.add_argument('--update', action='store_true', help='Atualiza a base de dados local')\n    parser.add_argument('--alltime', action='store_true', help='Top 6 de todos os tempos')\n    parser.add_argument('--lastyear', action='store_true', help='Top 6 do √∫ltimo ano')\n    parser.add_argument('--stat', action='store_true', help='Conjunto estat√≠stico ponderado')\n    parser.add_argument('--db-path', type=str, help='Caminho personalizado para o banco de dados')\n    parser.add_argument('--plot', action='store_true', help='Visualizar frequ√™ncia dos n√∫meros')\n    parser.add_argument('--montecarlo', action='store_true', help='Simula√ß√£o de Monte Carlo')\n    parser.add_argument('--correlation', action='store_true', help='Calcular correla√ß√£o entre n√∫meros')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "Draw = Tuple[datetime.date, Tuple[int, int, int, int, int, int]]\n# --- Banco de Dados ---\ndef init_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite, criando a tabela megasena se n√£o existir.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    }
]
[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NUM_DEZENAS",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "MAX_NUM_MEGA_SENA",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "DB_PATH",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_last_db_concurso",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "fetch_lottery_data",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "combinations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "init_user_sets_db",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def init_user_sets_db(path: str = USER_SETS_DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite para os conjuntos de números do usuário,\n    criando a tabela 'user_sets' se não existir.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute('''",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "save_user_set",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def save_user_set(name: str, numbers: List[int], path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Salva um conjunto de 6 números gerados pelo usuário na base de dados.\n    Atualiza um conjunto existente se o nome for o mesmo, caso contrário, insere um novo.\n    \"\"\"\n    init_user_sets_db(path)\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "load_user_sets",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def load_user_sets(path: str = USER_SETS_DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Carrega todos os conjuntos de números salvos pelo usuário.\n    \"\"\"\n    init_user_sets_db(path)\n    conn: Optional[sqlite3.Connection] = None\n    user_sets: List[Dict[str, Any]] = []\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "delete_user_set",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def delete_user_set(set_id: int, path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Deleta um conjunto de números do usuário pelo ID.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute(\"DELETE FROM user_sets WHERE id = ?\", (set_id,))\n        conn.commit()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_with_latest_draw",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def compare_user_sets_with_latest_draw(user_sets_path: str = USER_SETS_DB_PATH, mega_sena_db_path: str = DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Compara todos os conjuntos de números do usuário com o último sorteio da Mega-Sena.\n    Atualiza o banco de dados do usuário com os resultados da comparação.\n    Retorna uma lista de dicionários com os resultados da comparação.\n    \"\"\"\n    latest_draw_data: Optional[Dict[str, Any]] = None\n    try:\n        # Fetch the latest Mega-Sena draw from the official DB or API\n        # It's safer to get from API directly for latest, then from DB for historical",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def calculate_correlation(draws):\n    \"\"\"\n    Calcula a matriz de correlação entre os números sorteados.\n    \"\"\"\n    if pd is None:\n        logging.error(\"Pandas não está instalado. Não é possível calcular a correlação.\")\n        return None\n    data = []\n    for _, nums in draws:\n        draw_binary = [1 if i in nums else 0 for i in range(1, MAX_NUM_MEGA_SENA + 1)]",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def main():\n    import tkinter as tk\n    from tkinter import messagebox, simpledialog\n    root = tk.Tk()\n    root.geometry(\"500x400\")\n    root.title(\"Mega-Sena - Gerenciador de Conjuntos do Usuário\")\n    tk.Label(root, text=\"Mega-Sena - Gerenciador de Conjuntos do Usuário\", font=(\"Arial\", 14, \"bold\")).pack(pady=10)\n    # Botões principais\n    tk.Button(root, text=\"Salvar conjunto por frequência\", width=30, command=lambda: messagebox.showinfo(\"Info\", \"Funcionalidade de salvar por frequência\")).pack(pady=5)\n    tk.Button(root, text=\"Salvar conjunto ponderado\", width=30, command=lambda: messagebox.showinfo(\"Info\", \"Funcionalidade de salvar ponderado\")).pack(pady=5)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite, criando a tabela megasena se não existir.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS megasena (",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_last_db_concurso",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_last_db_concurso(path: str = DB_PATH) -> int:\n    \"\"\"\n    Retorna o número do último concurso registrado no banco de dados.\n    Retorna 0 se o banco de dados estiver vazio ou houver um erro.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()\n        cursor.execute('SELECT MAX(concurso) FROM megasena')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "fetch_lottery_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def fetch_lottery_data(lottery: str = \"megasena\", concurso: Optional[int] = None) -> Dict[str, Any]:\n    \"\"\"\n    Busca dados de um concurso específico de uma loteria na API.\n    Se 'concurso' for None, busca o último resultado.\n    \"\"\"\n    if lottery not in API_LOTERIAS:\n        raise ValueError(f\"Loteria '{lottery}' não suportada.\")\n    url: str = f\"{API_LOTERIAS[lottery]}/{concurso}\" if concurso else f\"{API_LOTERIAS[lottery]}/latest\"\n    try:\n        resp: requests.Response = requests.get(url)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "validate_api_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def validate_api_data(data: Dict[str, Any], lottery: str) -> bool:\n    \"\"\"\n    Valida os dados retornados pela API para a loteria especificada.\n    \"\"\"\n    if lottery == \"megasena\":\n        required_keys = {'concurso', 'data', 'dezenas'}\n        if not all(key in data for key in required_keys):\n            logging.warning(f\"Dados da API para Mega-Sena faltando chaves esperadas: {data.keys()}\")\n            return False\n        if not isinstance(data['dezenas'], list) or len(data['dezenas']) != NUM_DEZENAS:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "update_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def update_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Atualiza a base de dados local com os resultados mais recentes da Mega-Sena.\n    \"\"\"\n    init_db(path)\n    ultimo_db: int = get_last_db_concurso(path)\n    ultimo_api: int = 0\n    try:\n        data_last: Dict[str, Any] = fetch_lottery_data(\"megasena\", None)\n        ultimo_api = int(data_last['concurso'])",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def load_all_draws(path: str = DB_PATH) -> List[Draw]:\n    \"\"\"\n    Carrega todos os sorteios da Mega-Sena do banco de dados.\n    Retorna uma lista de tuplas (data, dezenas).\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    draws: List[Draw] = []\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent(draws: List[Draw], k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Calcula os k números mais frequentes em todos os sorteios.\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    return [num for num, _ in counter.most_common(k)]\ndef get_most_frequent_period(draws: List[Draw], days: int = 365, k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_period",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_period(draws: List[Draw], days: int = 365, k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Calcula os k números mais frequentes em um período específico (em dias).\n    \"\"\"\n    today = datetime.date.today()\n    cutoff = today - datetime.timedelta(days=days)\n    filtered = [(d, nums) for d, nums in draws if d >= cutoff]\n    if not filtered:\n        logging.warning(f\"Nenhum sorteio encontrado nos últimos {days} dias.\")\n        return []",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_weighted",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_weighted(draws: List[Draw], k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Gera um conjunto de números ponderado pela frequência histórica.\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    all_nums: List[int] = list(range(1, MAX_NUM_MEGA_SENA + 1))\n    weights: List[int] = [counter[n] for n in all_nums]\n    if sum(weights) == 0:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "plot_frequency",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def plot_frequency(draws: List[Draw]) -> None:\n    \"\"\"\n    Gera um gráfico de barras da frequência de cada número sorteado.\n    \"\"\"\n    if not plt:\n        logging.error(\"Matplotlib não está instalado. Não é possível gerar o gráfico de frequência.\")\n        return\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "monte_carlo_simulation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def monte_carlo_simulation(draws: List[Draw], simulations: int = 10000) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:\n    \"\"\"\n    Realiza uma simulação de Monte Carlo para comparar frequências simuladas com as reais.\n    Retorna os 6 números mais frequentes simulados e reais.\n    \"\"\"\n    if not np:\n        logging.error(\"NumPy não está instalado. Não é possível realizar a simulação de Monte Carlo.\")\n        return [], []\n    all_nums: List[int] = list(range(1, MAX_NUM_MEGA_SENA + 1))\n    simulated_counts: Counter = Counter()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def calculate_correlation(draws: List[Draw]) -> Optional[Any]:\n    \"\"\"\n    Calcula a matriz de correlação entre os números sorteados.\n    \"\"\"\n    if not pd:\n        logging.error(\"Pandas não está instalado. Não é possível calcular a correlação.\")\n        return None\n    data: List[List[int]] = []\n    for _, nums in draws:\n        # Create a binary array for each draw: 1 if number is present, 0 otherwise",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_probability_distribution",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_probability_distribution(draws: List[Draw]) -> Optional[Tuple[float, float]]:\n    \"\"\"\n    Analisa a distribuição de probabilidade dos números sorteados usando o teste Qui-quadrado.\n    Compara a frequência observada com uma distribuição uniforme esperada.\n    \"\"\"\n    if not chisquare:\n        logging.error(\"SciPy não está instalado. Não é possível realizar a análise de distribuição de probabilidade.\")\n        return None\n    counter: Counter = Counter()\n    for _, nums in draws:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_time_series",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_time_series(draws: List[Draw]) -> None:\n    \"\"\"\n    Analisa a série temporal dos sorteios, mostrando a frequência de sorteios ao longo do tempo.\n    \"\"\"\n    if not plt:\n        logging.error(\"Matplotlib não está instalado. Não é possível gerar o gráfico de séries temporais.\")\n        return\n    # Extract dates and count occurrences for each date\n    date_counts: Counter = Counter(d for d, _ in draws)\n    # Sort dates and get corresponding counts",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "sanitize_filename",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    Sanitiza um nome de arquivo para evitar path traversal e caracteres inválidos.\n    Permite apenas letras, números, underline, hífen, ponto e espaço.\n    \"\"\"\n    # Remove leading/trailing whitespace\n    filename = filename.strip()\n    # Replace any sequence of invalid characters with an underscore\n    filename = re.sub(r'[^\\w\\-. ]', '_', filename)\n    # Ensure it's not empty after sanitization",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def export_results(data: List[Tuple[Any, Any]], file_format: str = \"csv\", filename: str = \"results\", header: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Exporta resultados para CSV ou JSON.\n    É uma função mais genérica para a exportação de listas de tuplas/listas.\n    \"\"\"\n    full_filename: Optional[str] = None\n    try:\n        filename = sanitize_filename(filename)\n        full_filename = f\"{filename}.{file_format}\"\n        if file_format == \"csv\":",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "schedule_task_crossplatform",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def schedule_task_crossplatform() -> None:\n    \"\"\"\n    Agenda a atualização diária do banco de dados de forma multiplataforma.\n    Usa `schtasks` no Windows e fornece instrução para `crontab` em Linux/macOS.\n    \"\"\"\n    import platform\n    task_name: str = \"MegaSenaUpdate\"\n    script_path: str = os.path.abspath(__file__)\n    if platform.system() == \"Windows\":\n        command: str = f\"schtasks /create /tn \\\"{task_name}\\\" /tr \\\"cmd /c python {script_path} --update\\\" /sc daily /st 12:00 /F\"",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "connect_external_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def connect_external_db(conn_str: str) -> Optional[sqlite3.Connection]:\n    \"\"\"\n    Conecta-se a um banco de dados externo (exemplo para SQLite).\n    Pode ser adaptado para outros tipos de banco de dados (PostgreSQL, MySQL, etc.)\n    requerendo as bibliotecas apropriadas (e.g., psycopg2, mysql-connector-python).\n    \"\"\"\n    logging.info(f\"Tentando conectar ao banco de dados externo com: {conn_str}\")\n    try:\n        # For SQLite, conn_str is typically the path to the database file\n        conn = sqlite3.connect(conn_str)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "filter_draws_by_period",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def filter_draws_by_period(draws: List[Draw], start_date: Optional[datetime.date] = None, end_date: Optional[datetime.date] = None) -> List[Draw]:\n    \"\"\"\n    Filtra os sorteios por um período de datas.\n    \"\"\"\n    if not start_date and not end_date:\n        return draws\n    filtered_draws: List[Draw] = []\n    for d, nums in draws:\n        if start_date and d < start_date:\n            continue",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_pairs",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_pairs(draws: List[Draw], k: int = NUM_DEZENAS) -> List[Tuple[Tuple[int, int], int]]:\n    \"\"\"\n    Calcula os k pares de números mais frequentes em todos os sorteios.\n    Retorna uma lista de tuplas (par, frequência).\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        # Ensure numbers are sorted within the tuple for consistent counting\n        for pair in combinations(sorted(nums), 2):\n            counter[pair] += 1",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_triplets",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_triplets(draws: List[Draw], k: int = NUM_DEZENAS) -> List[Tuple[Tuple[int, int, int], int]]:\n    \"\"\"\n    Calcula os k trios de números mais frequentes em todos os sorteios.\n    Retorna uma lista de tuplas (trio, frequência).\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        # Ensure numbers are sorted within the tuple for consistent counting\n        for triplet in combinations(sorted(nums), 3):\n            counter[triplet] += 1",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "conditional_probability",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def conditional_probability(draws: List[Draw], given: int, target: int) -> float:\n    \"\"\"\n    Calcula a probabilidade condicional de 'target' ser sorteado, dado que 'given' foi sorteado.\n    P(Target | Given) = P(Target e Given) / P(Given)\n    \"\"\"\n    if not (1 <= given <= MAX_NUM_MEGA_SENA) or not (1 <= target <= MAX_NUM_MEGA_SENA):\n        logging.error(f\"Números 'given' ({given}) e/ou 'target' ({target}) fora do intervalo válido (1-{MAX_NUM_MEGA_SENA}).\")\n        return 0.0\n    if given == target:\n        logging.warning(\"Probabilidade condicional de um número dado ele mesmo é 1.0 (se ele já saiu).\")",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_web_interface",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def run_web_interface(draws: List[Draw]) -> None:\n    \"\"\"\n    Inicia uma interface web Flask para exibir estatísticas.\n    \"\"\"\n    if not Flask:\n        logging.error(\"Flask não está instalado. Não é possível iniciar a interface web.\")\n        return\n    app = Flask(__name__)\n    @app.route(\"/frequencia\")\n    def frequencia():",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "init_user_sets_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_user_sets_db(path: str = USER_SETS_DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite para os conjuntos de números do usuário,\n    criando a tabela 'user_sets' se não existir.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor = conn.cursor()\n        cursor.execute('''",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "save_user_set",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def save_user_set(name: str, numbers: List[int], path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Salva um conjunto de 6 números gerados pelo usuário na base de dados.\n    Atualiza um conjunto existente se o nome for o mesmo, caso contrário, insere um novo.\n    \"\"\"\n    init_user_sets_db(path)\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_user_sets",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def load_user_sets(path: str = USER_SETS_DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Carrega todos os conjuntos de números salvos pelo usuário.\n    \"\"\"\n    init_user_sets_db(path)\n    conn: Optional[sqlite3.Connection] = None\n    user_sets: List[Dict[str, Any]] = []\n    try:\n        conn = sqlite3.connect(path)\n        cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "delete_user_set",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def delete_user_set(set_id: int, path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Deleta um conjunto de números do usuário pelo ID.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor = conn.cursor()\n        cursor.execute(\"DELETE FROM user_sets WHERE id = ?\", (set_id,))\n        conn.commit()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_with_latest_draw",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def compare_user_sets_with_latest_draw(user_sets_path: str = USER_SETS_DB_PATH, mega_sena_db_path: str = DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Compara todos os conjuntos de números do usuário com o último sorteio da Mega-Sena.\n    Atualiza o banco de dados do usuário com os resultados da comparação.\n    Retorna uma lista de dicionários com os resultados da comparação.\n    \"\"\"\n    latest_draw_data: Optional[Dict[str, Any]] = None\n    try:\n        all_draws = load_all_draws(mega_sena_db_path)\n        if not all_draws:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "salvar_aposta_usuario",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def salvar_aposta_usuario(numeros: list, origem: str):\n    \"\"\"\n    Salva o conjunto de 6 números escolhido pelo usuário em um arquivo separado.\n    \"\"\"\n    import csv\n    from datetime import datetime\n    if len(numeros) != 6:\n        raise ValueError(\"A aposta deve conter exatamente 6 números.\")\n    numeros_ordenados = sorted(numeros)\n    existe = os.path.exists(USER_BETS_FILE)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "comparar_aposta_com_ultimo_resultado",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def comparar_aposta_com_ultimo_resultado():\n    \"\"\"\n    Compara a última aposta salva pelo usuário com o último resultado oficial da Mega-Sena.\n    \"\"\"\n    import csv\n    if not os.path.exists(USER_BETS_FILE):\n        print(\"Nenhuma aposta de usuário encontrada.\")\n        return\n    # Carrega última aposta\n    with open(USER_BETS_FILE, \"r\", encoding=\"utf-8\") as f:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calcular_nivel_confianca",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def calcular_nivel_confianca(draws: List[Draw], conjunto: List[int]) -> float:\n    \"\"\"\n    Calcula um nível de confiança empírico para um conjunto de 6 números.\n    Aqui, soma as frequências relativas de cada número no histórico.\n    \"\"\"\n    counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    total = sum(counter.values())\n    if total == 0:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "salvar_jogo_usuario",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def salvar_jogo_usuario(conjunto: List[int], modo: str, nivel_confianca: float, arquivo: str = \"meus_jogos.csv\"):\n    \"\"\"\n    Salva o conjunto de números gerado pelo usuário em um arquivo separado.\n    \"\"\"\n    import csv\n    from datetime import datetime\n    existe = os.path.exists(arquivo)\n    with open(arquivo, \"a\", newline=\"\", encoding=\"utf-8\") as f:\n        writer = csv.writer(f)\n        if not existe:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description='Mega-Sena Analyzer')\n    parser.add_argument('--update', action='store_true', help='Atualiza a base de dados local')\n    parser.add_argument('--alltime', action='store_true', help='Top 6 de todos os tempos')\n    parser.add_argument('--lastyear', action='store_true', help='Top 6 do último ano')\n    parser.add_argument('--stat', action='store_true', help='Conjunto estatístico ponderado')\n    parser.add_argument('--db-path', type=str, help='Caminho personalizado para o banco de dados')\n    parser.add_argument('--plot', action='store_true', help='Visualizar frequência dos números')\n    parser.add_argument('--montecarlo', action='store_true', help='Simulação de Monte Carlo')\n    parser.add_argument('--correlation', action='store_true', help='Calcular correlação entre números')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "Draw = Tuple[datetime.date, Tuple[int, int, int, int, int, int]]\n# --- Banco de Dados ---\ndef init_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite, criando a tabela megasena se não existir.\n    \"\"\"\n    conn: Optional[sqlite3.Connection] = None\n    try:\n        conn = sqlite3.connect(path)\n        cursor: sqlite3.Cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "USER_BETS_FILE",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "USER_BETS_FILE = \"apostas_usuario.csv\"\ndef salvar_aposta_usuario(numeros: list, origem: str):\n    \"\"\"\n    Salva o conjunto de 6 números escolhido pelo usuário em um arquivo separado.\n    \"\"\"\n    import csv\n    from datetime import datetime\n    if len(numeros) != 6:\n        raise ValueError(\"A aposta deve conter exatamente 6 números.\")\n    numeros_ordenados = sorted(numeros)",
        "detail": "mega_sena_app",
        "documentation": {}
    }
]
[
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Menu",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_period",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_weighted",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "monte_carlo_simulation",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "plot_frequency",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_time_series",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_probability_distribution",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "update_db",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "chisquare",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "run_analysis",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_analysis(option):\n    draws = load_all_draws()\n    if not draws:\n        messagebox.showerror(\"Erro\", \"Base de dados vazia. Execute a atualização primeiro.\")\n        return\n    if option == \"alltime\":\n        result = get_most_frequent(draws)\n        messagebox.showinfo(\"Top 6 de Todos os Tempos\", f\"Números: {result}\")\n    elif option == \"lastyear\":\n        result = get_most_frequent_period(draws)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "export_data",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def export_data():\n    draws = load_all_draws()\n    if not draws:\n        messagebox.showerror(\"Erro\", \"Base de dados vazia. Execute a atualização primeiro.\")\n        return\n    file_path = filedialog.asksaveasfilename(defaultextension=\".csv\", filetypes=[(\"CSV files\", \"*.csv\"), (\"JSON files\", \"*.json\")])\n    if file_path:\n        file_format = file_path.split('.')[-1]\n        export_results(draws, file_format, file_path.rsplit('.', 1)[0])\n        messagebox.showinfo(\"Exportação\", f\"Dados exportados para {file_path}\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_help",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_help():\n    help_text = \"\"\"\n    - Atualizar Base de Dados: Atualiza os resultados da Mega-Sena.\n    - Top 6 de Todos os Tempos: Mostra os números mais frequentes em todos os sorteios.\n    - Top 6 do Último Ano: Mostra os números mais frequentes nos últimos 365 dias.\n    - Conjunto Estatístico Ponderado: Calcula números baseados em ponderação estatística.\n    - Visualizar Frequência: Exibe um gráfico de frequência dos números sorteados.\n    - Simulação de Monte Carlo: Simula sorteios para estimar números frequentes.\n    - Correlação: Calcula a correlação entre os números sorteados.\n    - Séries Temporais: Exibe a tendência de sorteios ao longo do tempo.",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "open_github",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def open_github():\n    webbrowser.open(\"https://github.com/marcosfland/mega_sena_estatistico\")\ndef show_about():\n    about_text = \"Mega-Sena Estatístico\\nVersão 1.0\\nDesenvolvido por Marcos\\nAnálise estatística de sorteios da Mega-Sena.\"\n    messagebox.showinfo(\"Sobre\", about_text)\ndef create_gui():\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")\n    # Menu superior\n    menu_bar = Menu(root)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_about",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_about():\n    about_text = \"Mega-Sena Estatístico\\nVersão 1.0\\nDesenvolvido por Marcos\\nAnálise estatística de sorteios da Mega-Sena.\"\n    messagebox.showinfo(\"Sobre\", about_text)\ndef create_gui():\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")\n    # Menu superior\n    menu_bar = Menu(root)\n    root.config(menu=menu_bar)\n    # Menu Arquivo",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "create_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def create_gui():\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")\n    # Menu superior\n    menu_bar = Menu(root)\n    root.config(menu=menu_bar)\n    # Menu Arquivo\n    file_menu = Menu(menu_bar, tearoff=0)\n    file_menu.add_command(label=\"Atualizar Base de Dados\", command=update_db)\n    file_menu.add_command(label=\"Exportar Dados\", command=export_data)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_db(path: str = DB_PATH):\n    conn = sqlite3.connect(path)\n    cursor = conn.cursor()\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS megasena (\n            concurso INTEGER PRIMARY KEY,\n            data TEXT,\n            dez1 INTEGER, dez2 INTEGER, dez3 INTEGER,\n            dez4 INTEGER, dez5 INTEGER, dez6 INTEGER\n        )",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "fetch_lottery_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def fetch_lottery_data(lottery=\"megasena\", concurso=None):\n    url = f\"{API_LOTERIAS[lottery]}/{concurso}\" if concurso else f\"{API_LOTERIAS[lottery]}/latest\"\n    try:\n        resp = requests.get(url)\n        resp.raise_for_status()\n        return resp.json()\n    except requests.RequestException as e:\n        logging.error(f\"Erro ao buscar dados da API para {lottery}: {e}\")\n        raise\ndef fetch_concurso(concurso: int = None) -> dict:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "fetch_concurso",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def fetch_concurso(concurso: int = None) -> dict:\n    \"\"\"Busca JSON de um concurso específico ou último se concurso=None\"\"\"\n    url = f\"{API_BASE}/{concurso}\" if concurso else API_BASE + '/latest'\n    try:\n        resp = requests.get(url)\n        resp.raise_for_status()\n        data = resp.json()\n        if not validate_api_data(data):\n            raise ValueError(f\"Dados inválidos recebidos para o concurso {concurso}\")\n        return data",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "validate_api_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def validate_api_data(data: dict) -> bool:\n    \"\"\"Valida os dados retornados pela API\"\"\"\n    required_keys = {'concurso', 'data', 'dezenas'}\n    if not all(key in data for key in required_keys):\n        return False\n    if not isinstance(data['dezenas'], list) or len(data['dezenas']) != 6:\n        return False\n    return True\n# ---------------------\n# Atualização de Dados",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_last_db_concurso",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_last_db_concurso(path: str = DB_PATH) -> int:\n    conn = sqlite3.connect(path)\n    cursor = conn.cursor()\n    cursor.execute('SELECT MAX(concurso) FROM megasena')\n    row = cursor.fetchone()\n    conn.close()\n    return row[0] or 0\ndef update_db(path: str = DB_PATH):\n    init_db(path)\n    ultimo_db = get_last_db_concurso(path)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "update_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def update_db(path: str = DB_PATH):\n    init_db(path)\n    ultimo_db = get_last_db_concurso(path)\n    try:\n        data_last = fetch_concurso(None)\n        ultimo_api = int(data_last['concurso'])\n    except Exception as e:\n        logging.error(f\"Erro ao obter último concurso da API: {e}\")\n        return\n    if ultimo_api <= ultimo_db:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def load_all_draws(path: str = DB_PATH):\n    conn = sqlite3.connect(path)\n    cursor = conn.cursor()\n    cursor.execute('SELECT data, dez1, dez2, dez3, dez4, dez5, dez6 FROM megasena')\n    rows = cursor.fetchall()\n    conn.close()\n    draws = []\n    for data_str, *dez in rows:\n        date = datetime.datetime.strptime(data_str, '%d/%m/%Y').date()\n        draws.append((date, tuple(dez)))",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent(draws, k: int = 6):\n    counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    return [num for num, _ in counter.most_common(k)]\ndef get_most_frequent_period(draws, days: int = 365, k: int = 6):\n    today = datetime.date.today()\n    cutoff = today - datetime.timedelta(days=days)\n    filtered = [(d, nums) for d, nums in draws if d >= cutoff]\n    return get_most_frequent(filtered, k)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_period",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_period(draws, days: int = 365, k: int = 6):\n    today = datetime.date.today()\n    cutoff = today - datetime.timedelta(days=days)\n    filtered = [(d, nums) for d, nums in draws if d >= cutoff]\n    return get_most_frequent(filtered, k)\ndef get_weighted(draws, k: int = 6):\n    counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    all_nums = list(range(1, 61))",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_weighted",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_weighted(draws, k: int = 6):\n    counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    all_nums = list(range(1, 61))\n    weights = [counter[n] for n in all_nums]\n    if sum(weights) == 0:\n        return random.sample(all_nums, k)\n    probs = [w/sum(weights) for w in weights]\n    chosen = set()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "plot_frequency",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def plot_frequency(draws):\n    counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    numbers, frequencies = zip(*sorted(counter.items()))\n    plt.bar(numbers, frequencies)\n    plt.title('Frequência dos Números Sorteados')\n    plt.xlabel('Números')\n    plt.ylabel('Frequência')\n    plt.show()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "monte_carlo_simulation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def monte_carlo_simulation(draws, simulations=10000):\n    all_nums = list(range(1, 61))\n    simulated_counts = Counter()\n    for _ in range(simulations):\n        simulated_draw = np.random.choice(all_nums, size=6, replace=False)\n        simulated_counts.update(simulated_draw)\n    real_counts = Counter()\n    for _, nums in draws:\n        real_counts.update(nums)\n    # Retorna os 6 números mais frequentes simulados e reais",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def calculate_correlation(draws):\n    data = []\n    for _, nums in draws:\n        data.append([1 if i in nums else 0 for i in range(1, 61)])\n    df = pd.DataFrame(data, columns=[f'Num_{i}' for i in range(1, 61)])\n    correlation_matrix = df.corr()\n    return correlation_matrix\ndef analyze_probability_distribution(draws):\n    counter = Counter()\n    for _, nums in draws:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_probability_distribution",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_probability_distribution(draws):\n    counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    observed = [counter[i] for i in range(1, 61)]\n    expected = [sum(observed) / 60] * 60\n    chi2, p = chisquare(observed, expected)\n    return chi2, p\ndef analyze_time_series(draws):\n    dates = [d for d, _ in draws]",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_time_series",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_time_series(draws):\n    dates = [d for d, _ in draws]\n    frequencies = Counter(dates)\n    sorted_dates = sorted(frequencies.keys())\n    counts = [frequencies[date] for date in sorted_dates]\n    plt.plot(sorted_dates, counts)\n    plt.title('Tendência de Sorteios ao Longo do Tempo')\n    plt.xlabel('Data')\n    plt.ylabel('Frequência de Sorteios')\n    plt.show()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def export_results(data, file_format=\"csv\", filename=\"results\"):\n    if file_format == \"csv\":\n        with open(f\"{filename}.csv\", \"w\", newline=\"\") as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow([\"Número\", \"Frequência\"])\n            writer.writerows(data)\n    elif file_format == \"json\":\n        with open(f\"{filename}.json\", \"w\") as jsonfile:\n            json.dump(data, jsonfile, indent=4)\n    print(f\"Resultados exportados para {filename}.{file_format}\")",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "schedule_task",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def schedule_task():\n    task_name = \"MegaSenaUpdate\"\n    command = f\"schtasks /create /tn {task_name} /tr 'python {os.path.abspath(__file__)} --update' /sc daily /st 12:00\"\n    subprocess.run(command, shell=True)\n    print(f\"Tarefa agendada com sucesso: {task_name}\")\n# ---------------------\n# Interface de Linha de Comando\n# ---------------------\ndef main():\n    parser = argparse.ArgumentParser(description='Mega-Sena Analyzer')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description='Mega-Sena Analyzer')\n    parser.add_argument('--update', action='store_true', help='Atualiza a base de dados local')\n    parser.add_argument('--alltime', action='store_true', help='Top 6 de todos os tempos')\n    parser.add_argument('--lastyear', action='store_true', help='Top 6 do último ano')\n    parser.add_argument('--stat', action='store_true', help='Conjunto estatístico ponderado')\n    parser.add_argument('--db-path', type=str, help='Caminho personalizado para o banco de dados')\n    parser.add_argument('--plot', action='store_true', help='Visualizar frequência dos números')\n    parser.add_argument('--montecarlo', action='store_true', help='Simulação de Monte Carlo')\n    parser.add_argument('--correlation', action='store_true', help='Calcular correlação entre números')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "DB_PATH",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "DB_PATH = os.getenv('MEGASENA_DB_PATH', 'megasena.db')\nAPI_BASE = 'https://loteriascaixa-api.herokuapp.com/api/megasena'\n# Configuração de logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n# ---------------------\n# Banco de Dados\n# ---------------------\ndef init_db(path: str = DB_PATH):\n    conn = sqlite3.connect(path)\n    cursor = conn.cursor()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "API_BASE",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "API_BASE = 'https://loteriascaixa-api.herokuapp.com/api/megasena'\n# Configuração de logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n# ---------------------\n# Banco de Dados\n# ---------------------\ndef init_db(path: str = DB_PATH):\n    conn = sqlite3.connect(path)\n    cursor = conn.cursor()\n    cursor.execute('''",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "API_LOTERIAS",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "API_LOTERIAS = {\n    \"megasena\": \"https://loteriascaixa-api.herokuapp.com/api/megasena\",\n    \"quina\": \"https://loteriascaixa-api.herokuapp.com/api/quina\",\n    \"lotofacil\": \"https://loteriascaixa-api.herokuapp.com/api/lotofacil\"\n}\ndef fetch_lottery_data(lottery=\"megasena\", concurso=None):\n    url = f\"{API_LOTERIAS[lottery]}/{concurso}\" if concurso else f\"{API_LOTERIAS[lottery]}/latest\"\n    try:\n        resp = requests.get(url)\n        resp.raise_for_status()",
        "detail": "mega_sena_app",
        "documentation": {}
    }
]
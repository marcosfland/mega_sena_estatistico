[
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "cx_Freeze",
        "description": "cx_Freeze",
        "isExtraImport": true,
        "detail": "cx_Freeze",
        "documentation": {}
    },
    {
        "label": "Executable",
        "importPath": "cx_Freeze",
        "description": "cx_Freeze",
        "isExtraImport": true,
        "detail": "cx_Freeze",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Menu",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "mega_sena_app",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_period",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_weighted",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "monte_carlo_simulation",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "plot_frequency",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_time_series",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_probability_distribution",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "update_db",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_pairs",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_triplets",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "conditional_probability",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "filter_draws_by_period",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "sanitize_filename",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "save_user_set",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_user_sets",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_with_latest_draw",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "compare_numbers_with_latest_draw",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_backtest",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_backtest_summary",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "generate_smart_prediction",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_from_backtest_insights",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_number_gaps",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_cycles",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_sequences",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "find_exact_sequence",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "find_best_match_draw",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "NUM_DEZENAS",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "MAX_NUM_MEGA_SENA",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "init_db",
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "isExtraImport": true,
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "get_db_path",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "gui_db",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gui_db",
        "description": "gui_db",
        "detail": "gui_db",
        "documentation": {}
    },
    {
        "label": "select_db_gui",
        "importPath": "gui_db",
        "description": "gui_db",
        "isExtraImport": true,
        "detail": "gui_db",
        "documentation": {}
    },
    {
        "label": "logging.handlers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "combinations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "tempfile,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile.",
        "description": "tempfile.",
        "detail": "tempfile.",
        "documentation": {}
    },
    {
        "label": "gui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gui",
        "description": "gui",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "scripts.clean_markdown",
        "description": "scripts.clean_markdown",
        "peekOfCode": "ROOT = Path(__file__).resolve().parent.parent\nfiles = [\n    ROOT / 'SOLUCAO_DATABASE_LOCKED.md',\n    ROOT / 'BACKTEST_INSIGHTS_FEATURE.md',\n    ROOT / 'BACKTEST_INSIGHTS_IMPLEMENTATION.md'\n]\nlang_whitelist = ('bash','python','sql','text','sh','json','yaml','ini')\nfor f in files:\n    if not f.exists():\n        print(f\"Skipping {f}: not found\")",
        "detail": "scripts.clean_markdown",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 5,
        "importPath": "scripts.clean_markdown",
        "description": "scripts.clean_markdown",
        "peekOfCode": "files = [\n    ROOT / 'SOLUCAO_DATABASE_LOCKED.md',\n    ROOT / 'BACKTEST_INSIGHTS_FEATURE.md',\n    ROOT / 'BACKTEST_INSIGHTS_IMPLEMENTATION.md'\n]\nlang_whitelist = ('bash','python','sql','text','sh','json','yaml','ini')\nfor f in files:\n    if not f.exists():\n        print(f\"Skipping {f}: not found\")\n        continue",
        "detail": "scripts.clean_markdown",
        "documentation": {}
    },
    {
        "label": "lang_whitelist",
        "kind": 5,
        "importPath": "scripts.clean_markdown",
        "description": "scripts.clean_markdown",
        "peekOfCode": "lang_whitelist = ('bash','python','sql','text','sh','json','yaml','ini')\nfor f in files:\n    if not f.exists():\n        print(f\"Skipping {f}: not found\")\n        continue\n    s = f.read_text(encoding='utf-8')\n    original = s\n    # Remove outer fences if file starts with a fence and ends with a matching fence\n    lines = s.splitlines()\n    if lines and lines[0].strip().startswith('```') and lines[-1].strip().startswith('```'):",
        "detail": "scripts.clean_markdown",
        "documentation": {}
    },
    {
        "label": "get_git_version",
        "kind": 2,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "def get_git_version():\n    \"\"\"Obt√©m vers√£o do Git se dispon√≠vel\"\"\"\n    try:\n        # Tenta obter a tag mais recente\n        result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], \n                              capture_output=True, text=True, cwd=os.path.dirname(__file__))\n        if result.returncode == 0:\n            return result.stdout.strip()\n    except:\n        pass",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "get_build_info",
        "kind": 2,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "def get_build_info():\n    \"\"\"Obt√©m informa√ß√µes de build\"\"\"\n    try:\n        # Hash do commit atual\n        result = subprocess.run(['git', 'rev-parse', '--short', 'HEAD'], \n                              capture_output=True, text=True)\n        if result.returncode == 0:\n            commit_hash = result.stdout.strip()\n            return f\"build-{commit_hash}\"\n    except:",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "VERSION = get_git_version()\nBUILD_INFO = get_build_info()\nFULL_VERSION = f\"{VERSION}-{BUILD_INFO}\"\nprint(f\"üî® Vers√£o detectada: {FULL_VERSION}\")\n# Nome do arquivo principal do seu projeto\nmain_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "BUILD_INFO",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "BUILD_INFO = get_build_info()\nFULL_VERSION = f\"{VERSION}-{BUILD_INFO}\"\nprint(f\"üî® Vers√£o detectada: {FULL_VERSION}\")\n# Nome do arquivo principal do seu projeto\nmain_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "FULL_VERSION",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "FULL_VERSION = f\"{VERSION}-{BUILD_INFO}\"\nprint(f\"üî® Vers√£o detectada: {FULL_VERSION}\")\n# Nome do arquivo principal do seu projeto\nmain_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []\n}",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "main_script",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "main_script = \"main.py\"\n# Depend√™ncias adicionais (se houver)\nbuild_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []\n}\n# Informa√ß√µes do execut√°vel\nsetup(\n    name=\"MegaSenaEstatistico\",",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "build_exe_options",
        "kind": 5,
        "importPath": "build_executable",
        "description": "build_executable",
        "peekOfCode": "build_exe_options = {\n    \"packages\": [],\n    \"excludes\": [],\n    \"include_files\": []\n}\n# Informa√ß√µes do execut√°vel\nsetup(\n    name=\"MegaSenaEstatistico\",\n    version=\"1.0\",\n    description=\"Ferramenta estat√≠stica para Mega Sena\",",
        "detail": "build_executable",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "class Config:\n    \"\"\"Classe para gerenciar configura√ß√µes do aplicativo\"\"\"\n    def __init__(self, config_file: str = 'mega_sena_config.ini'):\n        self.config = configparser.ConfigParser()\n        self.config_file = config_file\n        self.load_config()\n    def load_config(self) -> None:\n        \"\"\"Carrega configura√ß√µes do arquivo ou cria configura√ß√µes padr√£o\"\"\"\n        if os.path.exists(self.config_file):\n            try:",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "def get_config() -> Config:\n    \"\"\"Retorna a inst√¢ncia global de configura√ß√£o\"\"\"\n    return app_config\n# Fun√ß√µes de conveni√™ncia para acessar configura√ß√µes comuns\ndef get_db_path() -> str:\n    \"\"\"Retorna o caminho do banco de dados\"\"\"\n    return app_config.get('DATABASE', 'path', 'megasena.db')\ndef get_monte_carlo_simulations() -> int:\n    \"\"\"Retorna o n√∫mero de simula√ß√µes Monte Carlo\"\"\"\n    return app_config.getint('ANALYSIS', 'monte_carlo_simulations', 10000)",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "get_db_path",
        "kind": 2,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "def get_db_path() -> str:\n    \"\"\"Retorna o caminho do banco de dados\"\"\"\n    return app_config.get('DATABASE', 'path', 'megasena.db')\ndef get_monte_carlo_simulations() -> int:\n    \"\"\"Retorna o n√∫mero de simula√ß√µes Monte Carlo\"\"\"\n    return app_config.getint('ANALYSIS', 'monte_carlo_simulations', 10000)\ndef get_gui_theme() -> str:\n    \"\"\"Retorna o tema da GUI\"\"\"\n    return app_config.get('GUI', 'theme', 'clam')\ndef get_web_port() -> int:",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "get_monte_carlo_simulations",
        "kind": 2,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "def get_monte_carlo_simulations() -> int:\n    \"\"\"Retorna o n√∫mero de simula√ß√µes Monte Carlo\"\"\"\n    return app_config.getint('ANALYSIS', 'monte_carlo_simulations', 10000)\ndef get_gui_theme() -> str:\n    \"\"\"Retorna o tema da GUI\"\"\"\n    return app_config.get('GUI', 'theme', 'clam')\ndef get_web_port() -> int:\n    \"\"\"Retorna a porta do servidor web\"\"\"\n    return app_config.getint('WEB', 'port', 5000)\ndef is_cache_enabled() -> bool:",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "get_gui_theme",
        "kind": 2,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "def get_gui_theme() -> str:\n    \"\"\"Retorna o tema da GUI\"\"\"\n    return app_config.get('GUI', 'theme', 'clam')\ndef get_web_port() -> int:\n    \"\"\"Retorna a porta do servidor web\"\"\"\n    return app_config.getint('WEB', 'port', 5000)\ndef is_cache_enabled() -> bool:\n    \"\"\"Verifica se o cache est√° habilitado\"\"\"\n    return app_config.getboolean('DATABASE', 'cache_enabled', True)\ndef is_auto_update_enabled() -> bool:",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "get_web_port",
        "kind": 2,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "def get_web_port() -> int:\n    \"\"\"Retorna a porta do servidor web\"\"\"\n    return app_config.getint('WEB', 'port', 5000)\ndef is_cache_enabled() -> bool:\n    \"\"\"Verifica se o cache est√° habilitado\"\"\"\n    return app_config.getboolean('DATABASE', 'cache_enabled', True)\ndef is_auto_update_enabled() -> bool:\n    \"\"\"Verifica se a atualiza√ß√£o autom√°tica est√° habilitada\"\"\"\n    return app_config.getboolean('GUI', 'auto_update', True)\nif __name__ == \"__main__\":",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "is_cache_enabled",
        "kind": 2,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "def is_cache_enabled() -> bool:\n    \"\"\"Verifica se o cache est√° habilitado\"\"\"\n    return app_config.getboolean('DATABASE', 'cache_enabled', True)\ndef is_auto_update_enabled() -> bool:\n    \"\"\"Verifica se a atualiza√ß√£o autom√°tica est√° habilitada\"\"\"\n    return app_config.getboolean('GUI', 'auto_update', True)\nif __name__ == \"__main__\":\n    # Teste das configura√ß√µes\n    config = get_config()\n    print(\"Configura√ß√µes atuais:\")",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "is_auto_update_enabled",
        "kind": 2,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "def is_auto_update_enabled() -> bool:\n    \"\"\"Verifica se a atualiza√ß√£o autom√°tica est√° habilitada\"\"\"\n    return app_config.getboolean('GUI', 'auto_update', True)\nif __name__ == \"__main__\":\n    # Teste das configura√ß√µes\n    config = get_config()\n    print(\"Configura√ß√µes atuais:\")\n    for section, settings in config.get_all_settings().items():\n        print(f\"\\n[{section}]\")\n        for key, value in settings.items():",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "app_config",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "app_config = Config()\ndef get_config() -> Config:\n    \"\"\"Retorna a inst√¢ncia global de configura√ß√£o\"\"\"\n    return app_config\n# Fun√ß√µes de conveni√™ncia para acessar configura√ß√µes comuns\ndef get_db_path() -> str:\n    \"\"\"Retorna o caminho do banco de dados\"\"\"\n    return app_config.get('DATABASE', 'path', 'megasena.db')\ndef get_monte_carlo_simulations() -> int:\n    \"\"\"Retorna o n√∫mero de simula√ß√µes Monte Carlo\"\"\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "check_db_integrity",
        "kind": 2,
        "importPath": "db_utils",
        "description": "db_utils",
        "peekOfCode": "def check_db_integrity(db_path: str) -> Tuple[bool, str]:\n    \"\"\"\n    Verifica a integridade do banco de dados SQLite.\n    Retorna: (is_healthy, message)\n    \"\"\"\n    if not os.path.exists(db_path):\n        return False, f\"Banco de dados n√£o encontrado: {db_path}\"\n    try:\n        with sqlite3.connect(db_path, timeout=20.0) as conn:\n            conn.execute('PRAGMA journal_mode=WAL')",
        "detail": "db_utils",
        "documentation": {}
    },
    {
        "label": "vacuum_db",
        "kind": 2,
        "importPath": "db_utils",
        "description": "db_utils",
        "peekOfCode": "def vacuum_db(db_path: str) -> Tuple[bool, str]:\n    \"\"\"\n    Otimiza o banco de dados removendo espa√ßo vazio.\n    Retorna: (success, message)\n    \"\"\"\n    if not os.path.exists(db_path):\n        return False, f\"Banco de dados n√£o encontrado: {db_path}\"\n    try:\n        with sqlite3.connect(db_path, timeout=20.0) as conn:\n            conn.execute('VACUUM')",
        "detail": "db_utils",
        "documentation": {}
    },
    {
        "label": "enable_wal_mode",
        "kind": 2,
        "importPath": "db_utils",
        "description": "db_utils",
        "peekOfCode": "def enable_wal_mode(db_path: str) -> Tuple[bool, str]:\n    \"\"\"\n    Ativa o modo Write-Ahead Logging (WAL) para reduzir locks.\n    Retorna: (success, message)\n    \"\"\"\n    if not os.path.exists(db_path):\n        return False, f\"Banco de dados n√£o encontrado: {db_path}\"\n    try:\n        with sqlite3.connect(db_path, timeout=20.0) as conn:\n            conn.execute('PRAGMA journal_mode=WAL')",
        "detail": "db_utils",
        "documentation": {}
    },
    {
        "label": "analyze_db",
        "kind": 2,
        "importPath": "db_utils",
        "description": "db_utils",
        "peekOfCode": "def analyze_db(db_path: str) -> Tuple[bool, str]:\n    \"\"\"\n    Analisa o banco para otimizar performance de queries.\n    Retorna: (success, message)\n    \"\"\"\n    if not os.path.exists(db_path):\n        return False, f\"Banco de dados n√£o encontrado: {db_path}\"\n    try:\n        with sqlite3.connect(db_path, timeout=20.0) as conn:\n            conn.execute('ANALYZE')",
        "detail": "db_utils",
        "documentation": {}
    },
    {
        "label": "get_db_info",
        "kind": 2,
        "importPath": "db_utils",
        "description": "db_utils",
        "peekOfCode": "def get_db_info(db_path: str) -> dict:\n    \"\"\"\n    Retorna informa√ß√µes sobre o banco de dados.\n    Retorna: dicion√°rio com info de tamanho, n√∫mero de tabelas, etc.\n    \"\"\"\n    if not os.path.exists(db_path):\n        return {'error': f'Banco n√£o encontrado: {db_path}'}\n    try:\n        size_bytes = os.path.getsize(db_path)\n        size_mb = size_bytes / (1024 * 1024)",
        "detail": "db_utils",
        "documentation": {}
    },
    {
        "label": "cleanup_databases",
        "kind": 2,
        "importPath": "db_utils",
        "description": "db_utils",
        "peekOfCode": "def cleanup_databases() -> dict:\n    \"\"\"\n    Realiza limpeza e otimiza√ß√£o de todos os bancos do projeto.\n    Retorna: dicion√°rio com resultados de cada opera√ß√£o\n    \"\"\"\n    databases = [\n        'megasena.db',\n        'user_sets.db',\n        'backtest.db'\n    ]",
        "detail": "db_utils",
        "documentation": {}
    },
    {
        "label": "run_command",
        "kind": 2,
        "importPath": "demo_multiple_backtest",
        "description": "demo_multiple_backtest",
        "peekOfCode": "def run_command(cmd):\n    \"\"\"Executa um comando e exibe resultado\"\"\"\n    print(f\"\\n{'='*70}\")\n    print(f\"Executando: {cmd}\")\n    print(f\"{'='*70}\")\n    result = subprocess.run(cmd, shell=True, capture_output=False, text=True)\n    return result.returncode\ndef main():\n    \"\"\"Demonstra diferentes usos da funcionalidade\"\"\"\n    print(\"\\n\" + \"=\"*70)",
        "detail": "demo_multiple_backtest",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "demo_multiple_backtest",
        "description": "demo_multiple_backtest",
        "peekOfCode": "def main():\n    \"\"\"Demonstra diferentes usos da funcionalidade\"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"DEMONSTRA√á√ÉO: Multiple Backtest Execution\")\n    print(\"=\"*70)\n    # Teste 1: Backtests simples (default)\n    print(\"\\n\\n[TESTE 1] Execu√ß√£o simples com default (weighted, 1x)\")\n    print(\"-\" * 70)\n    run_command(\"python mega_sena_app.py --backtest\")\n    # Teste 2: Alltime 1x",
        "detail": "demo_multiple_backtest",
        "documentation": {}
    },
    {
        "label": "Tooltip",
        "kind": 6,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "class Tooltip:\n    \"\"\"Simples tooltip para widgets Tkinter.\"\"\"\n    def __init__(self, widget, text=\"\"):\n        self.widget = widget\n        self.text = text\n        self.tipwindow = None\n        widget.bind(\"<Enter>\", self._on_enter)\n        widget.bind(\"<Leave>\", self._on_leave)\n    def _on_enter(self, event=None):\n        self.showtip()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_message",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_message(title, message, is_error=False):\n    \"\"\"Mostra mensagens de forma thread-safe (agendando no mainloop quando necess√°rio).\"\"\"\n    try:\n        is_main = threading.current_thread() is threading.main_thread()\n    except Exception:\n        is_main = True\n    def _show():\n        if status_bar:\n            status_bar.config(text=message)\n        if is_error:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "ask_on_main_thread",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def ask_on_main_thread(func, *args, **kwargs):\n    \"\"\"Executa uma chamada de UI no thread principal de forma s√≠ncrona e retorna o resultado.\n    Usa um Event para aguardar o t√©rmino da chamada agendada via root.after. Se j√° estiver\n    no thread principal, executa diretamente.\n    \"\"\"\n    try:\n        if threading.current_thread() is threading.main_thread() or root is None:\n            return func(*args, **kwargs)\n    except Exception:\n        # Se qualquer verifica√ß√£o falhar, tente executar diretamente",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "open_file_location",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def open_file_location(filepath):\n    try:\n        folder = os.path.dirname(os.path.abspath(filepath))\n        if os.name == 'nt':\n            os.startfile(folder)\n        elif os.name == 'posix':\n            subprocess.Popen(['xdg-open', folder])\n        show_message(\"Local Aberto\", f\"A pasta de '{filepath}' foi aberta.\", False)\n    except Exception as e:\n        show_message(\"Erro\", f\"N√£o foi poss√≠vel abrir o local do arquivo: {e}\", True)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "run_in_thread",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_in_thread(func, *args, **kwargs):\n    if status_bar:\n        status_bar.config(text=\"Processando... Por favor, aguarde.\")\n    thread = threading.Thread(target=lambda: func(*args, **kwargs))\n    thread.start()\ndef start_processing():\n    \"\"\"Ativa indicadores visuais de processamento: barra de progresso, cursor e desabilita bot√µes.\"\"\"\n    try:\n        if status_bar:\n            status_bar.config(text=\"Processando... Por favor, aguarde.\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "start_processing",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def start_processing():\n    \"\"\"Ativa indicadores visuais de processamento: barra de progresso, cursor e desabilita bot√µes.\"\"\"\n    try:\n        if status_bar:\n            status_bar.config(text=\"Processando... Por favor, aguarde.\")\n        if progress_bar:\n            progress_bar.start(10)\n        if root:\n            try:\n                root.config(cursor='watch')",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "display_results_table",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def display_results_table(headers, rows):\n    \"\"\"Preenche o Treeview com os cabe√ßalhos e linhas fornecidas.\n    headers: lista de strings para as colunas\n    rows: lista de iterables que correspondem √†s colunas\n    \"\"\"\n    global results_tree, current_results_data, current_results_headers\n    try:\n        if not results_tree:\n            return\n        # limpar √°rvore",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "export_results_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def export_results_gui():\n    \"\"\"Exporta os resultados atualmente exibidos na Treeview para arquivo CSV/JSON.\"\"\"\n    global current_results_headers, current_results_data\n    try:\n        if not current_results_data or not current_results_headers:\n            show_message(\"Erro\", \"Nenhum resultado dispon√≠vel para exportar.\", True)\n            return\n        file_path = ask_on_main_thread(filedialog.asksaveasfilename, defaultextension=\".csv\", filetypes=[(\"CSV files\", \"*.csv\"), (\"JSON files\", \"*.json\")], parent=root)\n        if not file_path:\n            return",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "embed_figure",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def embed_figure(fig):\n    \"\"\"Insere um objeto matplotlib.figure.Figure no painel de resultados (se suportado).\"\"\"\n    global mpl_canvas, results_tree\n    try:\n        if not FigureCanvasTkAgg:\n            show_message(\"Gr√°fico\", \"Matplotlib/TkAgg n√£o dispon√≠vel; abrindo em janela externa.\", False)\n            try:\n                import matplotlib.pyplot as _plt\n                _plt.figure(fig.number if hasattr(fig, 'number') else None)\n                _plt.show()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "stop_processing",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def stop_processing():\n    \"\"\"Desativa indicadores visuais de processamento e restaura estado da UI.\"\"\"\n    try:\n        if progress_bar:\n            progress_bar.stop()\n        if status_bar:\n            status_bar.config(text=\"Pronto\")\n        if root:\n            try:\n                root.config(cursor='')",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "run_analysis_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_analysis_gui(option):\n    # Iniciar indicador antes de disparar a thread\n    if root:\n        root.after(0, start_processing)\n    def _run():\n        try:\n            draws = load_all_draws()\n            if not draws:\n                show_message(\"Erro\", \"Base de dados vazia. Execute a atualiza√ß√£o primeiro.\", True)\n                return",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "export_data_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def export_data_gui(advanced=False):\n    def _export():\n        try:\n            draws = load_all_draws()\n            if not draws:\n                show_message(\"Erro\", \"Base de dados vazia. Execute a atualiza√ß√£o primeiro.\", True)\n                return\n            if advanced:\n                # Pedir o tipo em thread-safe no mainloop\n                tipo = ask_on_main_thread(simpledialog.askstring, \"Exporta√ß√£o Avan√ßada\", \"Tipo de an√°lise (frequencia, pares, trios, correlacao):\", parent=root)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "update_db_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def update_db_gui():\n    def _update():\n        try:\n            update_db()\n            show_message(\"Atualiza√ß√£o\", \"Base de dados atualizada com sucesso!\", False)\n        except Exception as e:\n            show_message(\"Erro na Atualiza√ß√£o\", f\"Ocorreu um erro ao atualizar a base de dados: {e}\", True)\n    run_in_thread(_update)\ndef generate_and_save_user_set_gui():\n    def _generate_and_save():",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "generate_and_save_user_set_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def generate_and_save_user_set_gui():\n    def _generate_and_save():\n        draws = load_all_draws()\n        if not draws:\n            show_message(\"Erro\", \"Base de dados vazia. Atualize primeiro para gerar n√∫meros.\", True)\n            return\n        method = simpledialog.askstring(\"Gerar Meus N√∫meros\", \"Escolha o m√©todo (alltime, lastyear, weighted, prediction, backtest-insights):\", parent=root)\n        if not method: return\n        generated_numbers: Optional[List[int]] = []\n        if method == \"alltime\":",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def compare_user_sets_gui():\n    def _compare():\n        try:\n            user_sets = load_user_sets()\n            if user_sets:\n                comparison_results = compare_user_sets_with_latest_draw()\n                if not comparison_results:\n                    if root:\n                        root.after(0, lambda: show_message(\"Erro\", \"N√£o foi poss√≠vel realizar a compara√ß√£o. Verifique a base de dados da Mega-Sena e a conex√£o com a API.\", True))\n                    else:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "search_sequence_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def search_sequence_gui():\n    \"\"\"Solicita 6 n√∫meros ao usu√°rio e procura no hist√≥rico por essa sequ√™ncia.\n    Se n√£o encontrada, mostra o sorteio com maior n√∫mero de acertos.\"\"\"\n    s = simpledialog.askstring(\"Pesquisar Sequ√™ncia\", \"Informe 6 n√∫meros separados por v√≠rgula (ex: 1,4,23,34,45,56):\", parent=root)\n    if not s:\n        return\n    try:\n        nums = [int(x.strip()) for x in s.split(',') if x.strip() != '']\n    except ValueError:\n        show_message(\"Erro\", \"Formato inv√°lido. Informe somente n√∫meros separados por v√≠rgula.\", True)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "toggle_compare_button_state",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def toggle_compare_button_state():\n    global compare_button, compare_hint_label\n    if compare_button is not None:\n        user_sets = load_user_sets()\n        # Mant√©m o bot√£o habilitado para permitir compara√ß√£o manual quando n√£o h√° conjuntos salvos\n        compare_button.config(state=tk.NORMAL)\n        if not user_sets:\n            # DX: mostrar dica clara quando n√£o h√° conjuntos salvos\n            if compare_hint_label is not None:\n                compare_hint_label.config(text=f\"Nenhum conjunto salvo ‚Äî clique para comparar manualmente {NUM_DEZENAS} n√∫meros\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "run_backtest_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def run_backtest_gui(method: Optional[str] = None):\n    \"\"\"Permite ao usu√°rio escolher um m√©todo e executa o backtest.\"\"\"\n    def _prompt_and_run():\n        if not method:\n            selected_method = simpledialog.askstring(\"Executar Backtest\", \"Escolha o m√©todo (alltime, lastyear, weighted):\", parent=root)\n            if not selected_method:\n                return\n        else:\n            selected_method = method\n        show_message(\"Backtest\", f\"Iniciando backtest para o m√©todo '{selected_method}'...\", False)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_backtest_results_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_backtest_results_gui(method: str):\n    \"\"\"Exibe os resultados do backtest em uma janela.\"\"\"\n    summary = get_backtest_summary(method)\n    if not summary['numbers']:\n        show_message(\"Erro\", f\"Nenhum resultado de backtest encontrado para o m√©todo '{method}'.\", True)\n        return\n    result_text = f\"Backtest para o m√©todo: '{summary['method']}'\\n\"\n    result_text += f\"N√∫meros gerados: {summary['numbers']}\\n\\n\"\n    result_text += f\"Resultado contra {summary['total_draws']} sorteios hist√≥ricos:\\n\"\n    # Calculate total matches",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_help",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_help():\n    help_text = \"\"\"\n    **Mega-Sena Analyzer GUI**\n    - **Atualizar Base de Dados**: Busca os √∫ltimos resultados da Mega-Sena e os armazena localmente.\n    - **Top 6 de Todos os Tempos**: Mostra os n√∫meros sorteados com maior frequ√™ncia em todo o hist√≥rico.\n    - **Top 6 do √öltimo Ano**: Identifica os n√∫meros mais frequentes nos √∫ltimos 365 dias.\n    - **Conjunto Estat√≠stico Ponderado**: Sugere um conjunto de 6 n√∫meros baseado na frequ√™ncia hist√≥rica, dando mais peso aos n√∫meros mais sorteados.\n    - **Visualizar Frequ√™ncia**: Abre um gr√°fico de barras mostrando a frequ√™ncia de cada n√∫mero (1 a 60).\n    - **Simula√ß√£o de Monte Carlo**: Simula milhares de sorteios aleat√≥rios para comparar as frequ√™ncias simuladas com as reais.\n    - **Correla√ß√£o**: Calcula a matriz de correla√ß√£o entre os n√∫meros, indicando quais n√∫meros tendem a sair juntos (para exporta√ß√£o avan√ßada).",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "open_github",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def open_github():\n    webbrowser.open(\"https://github.com/marcosfland/mega_sena_estatistico\")\n    show_message(\"Informa√ß√£o\", \"Reposit√≥rio do GitHub aberto no navegador.\", False)\ndef show_about():\n    about_text = \"Mega-Sena Analyzer\\nVers√£o 1.3 (Backtest de Estrat√©gias)\\nDesenvolvido por Marcos\\n\\nFerramenta de an√°lise estat√≠stica para os sorteios da Mega-Sena.\"\n    messagebox.showinfo(\"Sobre o Mega-Sena Analyzer\", about_text)\ndef create_gui():\n    global root, status_bar, compare_button\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "show_about",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def show_about():\n    about_text = \"Mega-Sena Analyzer\\nVers√£o 1.3 (Backtest de Estrat√©gias)\\nDesenvolvido por Marcos\\n\\nFerramenta de an√°lise estat√≠stica para os sorteios da Mega-Sena.\"\n    messagebox.showinfo(\"Sobre o Mega-Sena Analyzer\", about_text)\ndef create_gui():\n    global root, status_bar, compare_button\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")\n    root.geometry(\"700x950\") # Aumentado para acomodar novos bot√µes\n    root.resizable(False, False)\n    icon_path = get_resource_path(\"icon.png\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "create_gui",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def create_gui():\n    global root, status_bar, compare_button\n    root = tk.Tk()\n    root.title(\"Mega-Sena Analyzer\")\n    root.geometry(\"700x950\") # Aumentado para acomodar novos bot√µes\n    root.resizable(False, False)\n    icon_path = get_resource_path(\"icon.png\")\n    if os.path.exists(icon_path) and Image:\n        try:\n            icon_image = tk.PhotoImage(file=icon_path)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "get_resource_path",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def get_resource_path(relative_path):\n    base_path = getattr(sys, '_MEIPASS', os.path.abspath(os.path.dirname(__file__)))\n    return os.path.join(base_path, relative_path)\nif __name__ == \"__main__\":\n    if not os.path.exists(get_resource_path(\"icon.png\")):\n        try:\n            if Image and ImageDraw:\n                img = Image.new('RGBA', (32, 32), (0, 0, 0, 0))\n                draw = ImageDraw.Draw(img)\n                draw.ellipse((2, 2, 30, 30), fill='#FFD700', outline='#DAA520')",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "root = None\nstatus_bar = None\ncompare_button = None\ncompare_hint_label = None\nprogress_bar = None\ninteractive_buttons = []  # Lista de bot√µes que devem ser desativados durante processamento\ndef show_message(title, message, is_error=False):\n    \"\"\"Mostra mensagens de forma thread-safe (agendando no mainloop quando necess√°rio).\"\"\"\n    try:\n        is_main = threading.current_thread() is threading.main_thread()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "status_bar",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "status_bar = None\ncompare_button = None\ncompare_hint_label = None\nprogress_bar = None\ninteractive_buttons = []  # Lista de bot√µes que devem ser desativados durante processamento\ndef show_message(title, message, is_error=False):\n    \"\"\"Mostra mensagens de forma thread-safe (agendando no mainloop quando necess√°rio).\"\"\"\n    try:\n        is_main = threading.current_thread() is threading.main_thread()\n    except Exception:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "compare_button",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "compare_button = None\ncompare_hint_label = None\nprogress_bar = None\ninteractive_buttons = []  # Lista de bot√µes que devem ser desativados durante processamento\ndef show_message(title, message, is_error=False):\n    \"\"\"Mostra mensagens de forma thread-safe (agendando no mainloop quando necess√°rio).\"\"\"\n    try:\n        is_main = threading.current_thread() is threading.main_thread()\n    except Exception:\n        is_main = True",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "compare_hint_label",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "compare_hint_label = None\nprogress_bar = None\ninteractive_buttons = []  # Lista de bot√µes que devem ser desativados durante processamento\ndef show_message(title, message, is_error=False):\n    \"\"\"Mostra mensagens de forma thread-safe (agendando no mainloop quando necess√°rio).\"\"\"\n    try:\n        is_main = threading.current_thread() is threading.main_thread()\n    except Exception:\n        is_main = True\n    def _show():",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "progress_bar",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "progress_bar = None\ninteractive_buttons = []  # Lista de bot√µes que devem ser desativados durante processamento\ndef show_message(title, message, is_error=False):\n    \"\"\"Mostra mensagens de forma thread-safe (agendando no mainloop quando necess√°rio).\"\"\"\n    try:\n        is_main = threading.current_thread() is threading.main_thread()\n    except Exception:\n        is_main = True\n    def _show():\n        if status_bar:",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "interactive_buttons",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "interactive_buttons = []  # Lista de bot√µes que devem ser desativados durante processamento\ndef show_message(title, message, is_error=False):\n    \"\"\"Mostra mensagens de forma thread-safe (agendando no mainloop quando necess√°rio).\"\"\"\n    try:\n        is_main = threading.current_thread() is threading.main_thread()\n    except Exception:\n        is_main = True\n    def _show():\n        if status_bar:\n            status_bar.config(text=message)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "select_db_gui",
        "kind": 2,
        "importPath": "gui_db",
        "description": "gui_db",
        "peekOfCode": "def select_db_gui(label_widget: Optional[object] = None, parent=None):\n    \"\"\"Abre um di√°logo para selecionar/criar uma base de dados SQLite e persiste a escolha.\"\"\"\n    try:\n        file_path = filedialog.asksaveasfilename(defaultextension='.db', filetypes=[('SQLite DB','*.db'),('All files','*.*')], parent=parent)\n        if not file_path:\n            return None\n        cfg = get_config()\n        cfg.set('DATABASE', 'path', file_path)\n        cfg.save_config()\n        # Atualizar caminho global na aplica√ß√£o",
        "detail": "gui_db",
        "documentation": {}
    },
    {
        "label": "setup_enhanced_logging",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def setup_enhanced_logging(log_level: str = 'INFO', \n                          console_level: str = 'WARNING',\n                          max_file_size: int = 5 * 1024 * 1024,  # 5MB\n                          backup_count: int = 5) -> logging.Logger:\n    \"\"\"\n    Configura sistema de logs avan√ßado com rota√ß√£o\n    Args:\n        log_level: N√≠vel de log para arquivo (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n        console_level: N√≠vel de log para console\n        max_file_size: Tamanho m√°ximo do arquivo de log em bytes",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def get_logger(name: str = 'mega_sena') -> logging.Logger:\n    \"\"\"Retorna logger configurado\"\"\"\n    return logging.getLogger(name)\ndef log_function_call(func_name: str, args: tuple = (), kwargs: dict = {}) -> None:\n    \"\"\"Log de chamada de fun√ß√£o para debugging\"\"\"\n    logger = get_logger('mega_sena.debug')\n    args_str = ', '.join([str(arg) for arg in args])\n    kwargs_str = ', '.join([f\"{k}={v}\" for k, v in kwargs.items()])\n    all_args = ', '.join(filter(None, [args_str, kwargs_str]))\n    logger.debug(f\"Chamando {func_name}({all_args})\")",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "log_function_call",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def log_function_call(func_name: str, args: tuple = (), kwargs: dict = {}) -> None:\n    \"\"\"Log de chamada de fun√ß√£o para debugging\"\"\"\n    logger = get_logger('mega_sena.debug')\n    args_str = ', '.join([str(arg) for arg in args])\n    kwargs_str = ', '.join([f\"{k}={v}\" for k, v in kwargs.items()])\n    all_args = ', '.join(filter(None, [args_str, kwargs_str]))\n    logger.debug(f\"Chamando {func_name}({all_args})\")\ndef log_performance(func_name: str, duration: float, details: str = \"\") -> None:\n    \"\"\"Log de performance de fun√ß√£o\"\"\"\n    logger = get_logger('mega_sena.performance')",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "log_performance",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def log_performance(func_name: str, duration: float, details: str = \"\") -> None:\n    \"\"\"Log de performance de fun√ß√£o\"\"\"\n    logger = get_logger('mega_sena.performance')\n    logger.info(f\"Performance - {func_name}: {duration:.3f}s {details}\")\ndef log_user_action(action: str, details: str = \"\", user_id: str = \"default\") -> None:\n    \"\"\"Log de a√ß√£o do usu√°rio\"\"\"\n    logger = get_logger('mega_sena.gui')\n    logger.info(f\"Usu√°rio {user_id} - {action}: {details}\")\ndef log_analysis_result(analysis_type: str, result_count: int, duration: float = 0) -> None:\n    \"\"\"Log de resultado de an√°lise\"\"\"",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "log_user_action",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def log_user_action(action: str, details: str = \"\", user_id: str = \"default\") -> None:\n    \"\"\"Log de a√ß√£o do usu√°rio\"\"\"\n    logger = get_logger('mega_sena.gui')\n    logger.info(f\"Usu√°rio {user_id} - {action}: {details}\")\ndef log_analysis_result(analysis_type: str, result_count: int, duration: float = 0) -> None:\n    \"\"\"Log de resultado de an√°lise\"\"\"\n    logger = get_logger('mega_sena.analysis')\n    duration_str = f\" ({duration:.3f}s)\" if duration > 0 else \"\"\n    logger.info(f\"An√°lise {analysis_type} conclu√≠da: {result_count} resultados{duration_str}\")\ndef log_error_with_context(error: Exception, context: str = \"\", extra_data: dict = {}) -> None:",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "log_analysis_result",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def log_analysis_result(analysis_type: str, result_count: int, duration: float = 0) -> None:\n    \"\"\"Log de resultado de an√°lise\"\"\"\n    logger = get_logger('mega_sena.analysis')\n    duration_str = f\" ({duration:.3f}s)\" if duration > 0 else \"\"\n    logger.info(f\"An√°lise {analysis_type} conclu√≠da: {result_count} resultados{duration_str}\")\ndef log_error_with_context(error: Exception, context: str = \"\", extra_data: dict = {}) -> None:\n    \"\"\"Log de erro com contexto adicional\"\"\"\n    logger = get_logger('mega_sena')\n    error_msg = f\"Erro em {context}: {str(error)}\"\n    if extra_data:",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "log_error_with_context",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def log_error_with_context(error: Exception, context: str = \"\", extra_data: dict = {}) -> None:\n    \"\"\"Log de erro com contexto adicional\"\"\"\n    logger = get_logger('mega_sena')\n    error_msg = f\"Erro em {context}: {str(error)}\"\n    if extra_data:\n        error_msg += f\" | Dados: {extra_data}\"\n    logger.error(error_msg, exc_info=True)\ndef cleanup_old_logs(days_to_keep: int = 30) -> None:\n    \"\"\"Remove logs antigos\"\"\"\n    import glob",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "cleanup_old_logs",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def cleanup_old_logs(days_to_keep: int = 30) -> None:\n    \"\"\"Remove logs antigos\"\"\"\n    import glob\n    import time\n    log_dir = 'logs'\n    if not os.path.exists(log_dir):\n        return\n    cutoff_time = time.time() - (days_to_keep * 24 * 60 * 60)\n    for log_file in glob.glob(f\"{log_dir}/*.log*\"):\n        try:",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "log_function",
        "kind": 2,
        "importPath": "logging_config",
        "description": "logging_config",
        "peekOfCode": "def log_function(logger_name: str = 'mega_sena'):\n    \"\"\"Decorator para log autom√°tico de entrada e sa√≠da de fun√ß√£o\"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            logger = get_logger(logger_name)\n            func_name = func.__name__\n            # Log entrada\n            logger.debug(f\"Iniciando {func_name}\")\n            try:\n                result = func(*args, **kwargs)",
        "detail": "logging_config",
        "documentation": {}
    },
    {
        "label": "get_db_hash",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_db_hash(path: str = DB_PATH) -> str:\n    \"\"\"Gera hash do arquivo de banco para invalidar cache quando necess√°rio\"\"\"\n    try:\n        with open(path, 'rb') as f:\n            return hashlib.md5(f.read()).hexdigest()\n    except (FileNotFoundError, IOError):\n        return \"no_db\"\ndef invalidate_cache():\n    \"\"\"Invalida o cache de draws\"\"\"\n    try:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "invalidate_cache",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def invalidate_cache():\n    \"\"\"Invalida o cache de draws\"\"\"\n    try:\n        _load_all_draws_cached.cache_clear()\n    except Exception:\n        pass\n# --- Banco de Dados ---\ndef init_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite, criando a tabela megasena se n√£o existir.",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite, criando a tabela megasena se n√£o existir.\n    Adiciona √≠ndices para melhor performance.\n    \"\"\"\n    try:\n        # Se o arquivo existe mas est√° vazio (criado por NamedTemporaryFile em testes),\n        # remov√™-lo antes de abrir para evitar locks do descritor do arquivo original no Windows.\n        try:\n            if os.path.exists(path) and os.path.getsize(path) == 0:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "set_db_path",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def set_db_path(path: str) -> None:\n    \"\"\"Atualiza o caminho do banco de dados usado por padr√£o nas opera√ß√µes.\n    Atualiza a vari√°vel global `DB_PATH` e tenta invalidar caches relacionados.\n    \"\"\"\n    global DB_PATH\n    try:\n        if not path:\n            raise ValueError(\"Caminho inv√°lido para DB\")\n        DB_PATH = path\n        try:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_last_db_concurso",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_last_db_concurso(path: str = DB_PATH) -> int:\n    \"\"\"\n    Retorna o n√∫mero do √∫ltimo concurso registrado no banco de dados.\n    Retorna 0 se o banco de dados estiver vazio ou houver um erro.\n    \"\"\"\n    try:\n        with sqlite3.connect(path, timeout=20.0) as conn:\n            cursor: sqlite3.Cursor = conn.cursor()\n            cursor.execute('SELECT MAX(concurso) FROM megasena')\n            row = cursor.fetchone()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "fetch_lottery_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def fetch_lottery_data(lottery: str = \"megasena\", concurso: Optional[int] = None, retries: int = 3, timeout: int = 10) -> Dict[str, Any]:\n    \"\"\"\n    Busca dados de um concurso espec√≠fico de uma loteria na API com retries e timeout.\n    Se 'concurso' for None, busca o √∫ltimo resultado.\n    \"\"\"\n    if lottery not in API_LOTERIAS:\n        raise ValueError(f\"Loteria '{lottery}' n√£o suportada.\")\n    url: str = f\"{API_LOTERIAS[lottery]}/{concurso}\" if concurso else f\"{API_LOTERIAS[lottery]}/latest\"\n    last_exc = None\n    for attempt in range(1, retries + 1):",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "validate_api_data",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def validate_api_data(data: Dict[str, Any], lottery: str) -> bool:\n    \"\"\"\n    Valida os dados retornados pela API para a loteria especificada.\n    \"\"\"\n    if lottery == \"megasena\":\n        required_keys = {'concurso', 'data', 'dezenas'}\n        if not all(key in data for key in required_keys):\n            logging.warning(f\"Dados da API para Mega-Sena faltando chaves esperadas: {data.keys()}\")\n            return False\n        if not isinstance(data['dezenas'], list) or len(data['dezenas']) != NUM_DEZENAS:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "update_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def update_db(path: str = DB_PATH) -> None:\n    \"\"\"\n    Atualiza a base de dados local com os resultados mais recentes da Mega-Sena.\n    \"\"\"\n    init_db(path)\n    ultimo_db: int = get_last_db_concurso(path)\n    ultimo_api: int = 0\n    try:\n        data_last: Dict[str, Any] = fetch_lottery_data(\"megasena\", None)\n        ultimo_api = int(data_last['concurso'])",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_all_draws",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def load_all_draws(path: str = DB_PATH) -> List[Draw]:\n    \"\"\"Carrega todos os sorteios da Mega-Sena do banco de dados com cache baseado em hash do arquivo.\"\"\"\n    current_hash = get_db_hash(path)\n    return _load_all_draws_cached((path, current_hash))\ndef get_most_frequent(draws: List[Draw], k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Calcula os k n√∫meros mais frequentes em todos os sorteios.\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent(draws: List[Draw], k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Calcula os k n√∫meros mais frequentes em todos os sorteios.\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    return [num for num, _ in counter.most_common(k)]\ndef get_most_frequent_period(draws: List[Draw], days: int = 365, k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_period",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_period(draws: List[Draw], days: int = 365, k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Calcula os k n√∫meros mais frequentes em um per√≠odo espec√≠fico (em dias).\n    \"\"\"\n    today = datetime.date.today()\n    cutoff = today - datetime.timedelta(days=days)\n    filtered = [(d, nums) for d, nums in draws if d >= cutoff]\n    if not filtered:\n        logging.warning(f\"Nenhum sorteio encontrado nos √∫ltimos {days} dias.\")\n        return []",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_weighted",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_weighted(draws: List[Draw], k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Gera um conjunto de n√∫meros ponderado pela frequ√™ncia hist√≥rica.\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        counter.update(nums)\n    all_nums: List[int] = list(range(1, MAX_NUM_MEGA_SENA + 1))\n    weights: List[int] = [counter[n] for n in all_nums]\n    if sum(weights) == 0:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "open_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def open_db(path: str, timeout: float = 20.0):\n    \"\"\"Context manager para abrir conex√£o com DB garantindo que o modo WAL seja habilitado\n    e que a conex√£o seja fechada ao sair do contexto.\n    Usage:\n        with open_db(path) as conn:\n            # use conn\n    \"\"\"\n    @contextmanager\n    def _ctx():\n        conn = sqlite3.connect(path, timeout=timeout)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_from_backtest_insights",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_from_backtest_insights(method: str = \"weighted\", k: int = NUM_DEZENAS) -> List[int]:\n    \"\"\"\n    Gera um conjunto de n√∫meros baseado na an√°lise de resultados de backtest.\n    Utiliza os dados hist√≥ricos de quais n√∫meros foram mais bem-sucedidos\n    em acertar durante os backtests.\n    Args:\n        method: Qual m√©todo de backtest usar ('alltime', 'lastyear', 'weighted')\n        k: N√∫mero de dezenas a gerar (padr√£o 6)\n    Returns:\n        Lista de k n√∫meros ordenados, baseados no desempenho hist√≥rico",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "plot_frequency",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def plot_frequency(draws: List[Draw], return_fig: bool = False):\n    \"\"\"\n    Gera um gr√°fico de barras da frequ√™ncia de cada n√∫mero sorteado.\n    Se return_fig=True, retorna o objeto Figure ao inv√©s de chamar plt.show().\n    \"\"\"\n    if not plt:\n        logging.error(\"Matplotlib n√£o est√° instalado. N√£o √© poss√≠vel gerar o gr√°fico de frequ√™ncia.\")\n        return None if return_fig else None\n    counter: Counter = Counter()\n    for _, nums in draws:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "monte_carlo_simulation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def monte_carlo_simulation(draws: List[Draw], simulations: Optional[int] = None) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:\n    \"\"\"\n    Realiza uma simula√ß√£o de Monte Carlo para comparar frequ√™ncias simuladas com as reais.\n    Retorna os 6 n√∫meros mais frequentes simulados e reais.\n    \"\"\"\n    if not np:\n        logging.error(\"NumPy n√£o est√° instalado. N√£o √© poss√≠vel realizar a simula√ß√£o de Monte Carlo.\")\n        return [], []\n    # Usar configura√ß√£o se dispon√≠vel\n    if simulations is None:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_correlation",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def calculate_correlation(draws: List[Draw]) -> Optional[Any]:\n    \"\"\"\n    Calcula a matriz de correla√ß√£o entre os n√∫meros sorteados.\n    \"\"\"\n    if pd is None:\n        logging.error(\"Pandas n√£o est√° instalado. N√£o √© poss√≠vel calcular a correla√ß√£o.\")\n        return None\n    data: List[List[int]] = []\n    for _, nums in draws:\n        # Create a binary array for each draw: 1 if number is present, 0 otherwise",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_probability_distribution",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_probability_distribution(draws: List[Draw]) -> Optional[Tuple[float, float]]:\n    \"\"\"\n    Analisa a distribui√ß√£o de probabilidade dos n√∫meros sorteados usando o teste Qui-quadrado.\n    Compara a frequ√™ncia observada com uma distribui√ß√£o uniforme esperada.\n    \"\"\"\n    if not chisquare:\n        logging.error(\"SciPy n√£o est√° instalado. N√£o √© poss√≠vel realizar a an√°lise de distribui√ß√£o de probabilidade.\")\n        return None\n    counter: Counter = Counter()\n    for _, nums in draws:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_time_series",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_time_series(draws: List[Draw]) -> None:\n    \"\"\"\n    Analisa a s√©rie temporal dos sorteios, mostrando a frequ√™ncia de sorteios ao longo do tempo.\n    \"\"\"\n    if not plt:\n        logging.error(\"Matplotlib n√£o est√° instalado. N√£o √© poss√≠vel gerar o gr√°fico de s√©ries temporais.\")\n        return\n    # Extract dates and count occurrences for each date\n    date_counts: Counter = Counter(d for d, _ in draws)\n    # Sort dates and get corresponding counts",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "sanitize_filename",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    Sanitiza um nome de arquivo para evitar path traversal e caracteres inv√°lidos.\n    Permite apenas letras, n√∫meros, underline, h√≠fen, ponto e espa√ßo.\n    \"\"\"\n    # Remove leading/trailing whitespace\n    filename = filename.strip()\n    # Replace any sequence of invalid characters with an underscore\n    filename = re.sub(r'[^\\w\\-. ]', '_', filename)\n    # Ensure it's not empty after sanitization",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "export_results",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def export_results(data: List[Tuple[Any, Any]], file_format: str = \"csv\", filename: str = \"results\", header: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Exporta resultados para CSV ou JSON.\n    √â uma fun√ß√£o mais gen√©rica para a exporta√ß√£o de listas de tuplas/listas.\n    \"\"\"\n    full_filename: Optional[str] = None\n    try:\n        filename = sanitize_filename(filename)\n        full_filename = f\"{filename}.{file_format}\"\n        if file_format == \"csv\":",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "schedule_task_crossplatform",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def schedule_task_crossplatform() -> None:\n    \"\"\"\n    Agenda a atualiza√ß√£o di√°ria do banco de dados de forma multiplataforma.\n    Usa `schtasks` no Windows e fornece instru√ß√£o para `crontab` em Linux/macOS.\n    \"\"\"\n    import platform\n    task_name: str = \"MegaSenaUpdate\"\n    script_path: str = os.path.abspath(__file__)\n    if platform.system() == \"Windows\":\n        command: str = f\"schtasks /create /tn \\\"{task_name}\\\" /tr \\\"cmd /c python {script_path} --update\\\" /sc daily /st 12:00 /F\"",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "connect_external_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def connect_external_db(conn_str: str) -> Optional[sqlite3.Connection]:\n    \"\"\"\n    Conecta-se a um banco de dados externo (exemplo para SQLite).\n    Pode ser adaptado para outros tipos de banco de dados (PostgreSQL, MySQL, etc.)\n    requerendo as bibliotecas apropriadas (e.g., psycopg2, mysql-connector-python).\n    \"\"\"\n    logging.info(f\"Tentando conectar ao banco de dados externo com: {conn_str}\")\n    try:\n        # For SQLite, conn_str is typically the path to the database file\n        conn = sqlite3.connect(conn_str, timeout=20.0)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "filter_draws_by_period",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def filter_draws_by_period(draws: List[Draw], start_date: Optional[datetime.date] = None, end_date: Optional[datetime.date] = None) -> List[Draw]:\n    \"\"\"\n    Filtra os sorteios por um per√≠odo de datas.\n    \"\"\"\n    if not start_date and not end_date:\n        return draws\n    filtered_draws: List[Draw] = []\n    for d, nums in draws:\n        if start_date and d < start_date:\n            continue",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "find_exact_sequence",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def find_exact_sequence(numbers: List[int], path: str = DB_PATH) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Verifica se uma sequ√™ncia exata de 6 n√∫meros j√° foi sorteada.\n    Retorna um dicion√°rio com 'concurso' e 'data' se encontrada, ou None caso contr√°rio.\n    \"\"\"\n    if len(numbers) != NUM_DEZENAS:\n        raise ValueError(f\"A sequ√™ncia deve conter exatamente {NUM_DEZENAS} n√∫meros.\")\n    sorted_nums = sorted(numbers)\n    try:\n        with sqlite3.connect(path, timeout=20.0) as conn:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "find_best_match_draw",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def find_best_match_draw(numbers: List[int], path: str = DB_PATH) -> Dict[str, Any]:\n    \"\"\"\n    Procura o (ou os) sorteio(s) que possui(em) a maior quantidade de acertos em rela√ß√£o √† lista de n√∫meros fornecida.\n    Retorna um dicion√°rio com 'max_matches' e 'draws' onde 'draws' √© uma lista de dicion√°rios\n    contendo 'concurso', 'data' e 'dezenas'.\n    \"\"\"\n    if len(numbers) != NUM_DEZENAS:\n        raise ValueError(f\"A entrada deve conter exatamente {NUM_DEZENAS} n√∫meros.\")\n    target_set = set(numbers)\n    best = {'max_matches': 0, 'draws': []}",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_pairs",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_pairs(draws: List[Draw], k: int = NUM_DEZENAS) -> List[Tuple[Tuple[int, int], int]]:\n    \"\"\"\n    Calcula os k pares de n√∫meros mais frequentes em todos os sorteios.\n    Retorna uma lista de tuplas (par, frequ√™ncia).\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        # Ensure numbers are sorted within the tuple for consistent counting\n        for pair in combinations(sorted(nums), 2):\n            counter[pair] += 1",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_most_frequent_triplets",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_most_frequent_triplets(draws: List[Draw], k: int = NUM_DEZENAS) -> List[Tuple[Tuple[int, int, int], int]]:\n    \"\"\"\n    Calcula os k trios de n√∫meros mais frequentes em todos os sorteios.\n    Retorna uma lista de tuplas (trio, frequ√™ncia).\n    \"\"\"\n    counter: Counter = Counter()\n    for _, nums in draws:\n        # Ensure numbers are sorted within the tuple for consistent counting\n        for triplet in combinations(sorted(nums), 3):\n            counter[triplet] += 1",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "conditional_probability",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def conditional_probability(draws: List[Draw], given: int, target: int) -> float:\n    \"\"\"\n    Calcula a probabilidade condicional de 'target' ser sorteado, dado que 'given' foi sorteado.\n    P(Target | Given) = P(Target e Given) / P(Given)\n    \"\"\"\n    if not (1 <= given <= MAX_NUM_MEGA_SENA) or not (1 <= target <= MAX_NUM_MEGA_SENA):\n        logging.error(f\"N√∫meros 'given' ({given}) e/ou 'target' ({target}) fora do intervalo v√°lido (1-{MAX_NUM_MEGA_SENA}).\")\n        return 0.0\n    if given == target:\n        logging.warning(\"Probabilidade condicional de um n√∫mero dado ele mesmo √© 1.0 (se ele j√° saiu).\")",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_web_interface",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def run_web_interface(draws: List[Draw]) -> None:\n    \"\"\"\n    Inicia uma interface web Flask para exibir estat√≠sticas.\n    \"\"\"\n    if not Flask:\n        logging.error(\"Flask n√£o est√° instalado. N√£o √© poss√≠vel iniciar a interface web.\")\n        return\n    app = Flask(__name__)\n    @app.route(\"/frequencia\")\n    def frequencia():",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "calculate_prediction_score",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def calculate_prediction_score(number: int, draws: List[Draw]) -> float:\n    \"\"\"Calcula score preditivo baseado em m√∫ltiplos fatores\"\"\"\n    recent_weight = 0.4\n    frequency_weight = 0.3\n    gap_weight = 0.2\n    correlation_weight = 0.1\n    # Frequ√™ncia recente\n    recent_draws = draws[-50:] if len(draws) >= 50 else draws  # √öltimos 50 sorteios\n    recent_freq = sum(1 for _, nums in recent_draws if number in nums)\n    recent_score = recent_freq / len(recent_draws) if recent_draws else 0",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "generate_smart_prediction",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def generate_smart_prediction(draws: List[Draw]) -> List[Tuple[int, float]]:\n    \"\"\"Gera predi√ß√£o inteligente com scores\"\"\"\n    scores = []\n    for num in range(1, MAX_NUM_MEGA_SENA + 1):\n        score = calculate_prediction_score(num, draws)\n        scores.append((num, score))\n    return sorted(scores, key=lambda x: x[1], reverse=True)\ndef analyze_number_gaps(draws: List[Draw]) -> Dict[int, List[int]]:\n    \"\"\"Analisa intervalos entre apari√ß√µes de cada n√∫mero\"\"\"\n    gaps = {i: [] for i in range(1, MAX_NUM_MEGA_SENA + 1)}",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_number_gaps",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_number_gaps(draws: List[Draw]) -> Dict[int, List[int]]:\n    \"\"\"Analisa intervalos entre apari√ß√µes de cada n√∫mero\"\"\"\n    gaps = {i: [] for i in range(1, MAX_NUM_MEGA_SENA + 1)}\n    last_appearance = {i: -1 for i in range(1, MAX_NUM_MEGA_SENA + 1)}\n    for idx, (_, nums) in enumerate(draws):\n        for num in nums:\n            if last_appearance[num] != -1:\n                gaps[num].append(idx - last_appearance[num])\n            last_appearance[num] = idx\n    return gaps",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_cycles",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_cycles(draws: List[Draw]) -> Dict[str, Any]:\n    \"\"\"Identifica padr√µes c√≠clicos nos sorteios\"\"\"\n    weekday_patterns = Counter()\n    month_patterns = Counter()\n    for date, nums in draws:\n        weekday_patterns[date.weekday()] += 1\n        month_patterns[date.month] += 1\n    return {\n        'weekday_distribution': dict(weekday_patterns),\n        'month_distribution': dict(month_patterns)",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "analyze_sequences",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def analyze_sequences(draws: List[Draw]) -> Dict[str, Any]:\n    \"\"\"Analisa sequ√™ncias num√©ricas nos sorteios\"\"\"\n    consecutive_counts = Counter()\n    arithmetic_sequences = Counter()\n    for _, nums in draws:\n        sorted_nums = sorted(nums)\n        # Contar n√∫meros consecutivos\n        consecutive = 0\n        for i in range(len(sorted_nums) - 1):\n            if sorted_nums[i+1] == sorted_nums[i] + 1:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "init_user_sets_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_user_sets_db(path: str = USER_SETS_DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados SQLite para os conjuntos de n√∫meros do usu√°rio.\n    \"\"\"\n    try:\n        with sqlite3.connect(path, timeout=20.0) as conn:\n            cursor: sqlite3.Cursor = conn.cursor()\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS user_sets (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "save_user_set",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def save_user_set(name: str, numbers: List[int], path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Salva um conjunto de 6 n√∫meros gerados pelo usu√°rio na base de dados.\n    \"\"\"\n    init_user_sets_db(path)\n    try:\n        with sqlite3.connect(path, timeout=20.0) as conn:\n            cursor: sqlite3.Cursor = conn.cursor()\n            if len(numbers) != NUM_DEZENAS:\n                logging.error(f\"O conjunto de n√∫meros deve conter {NUM_DEZENAS} dezenas.\")",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "load_user_sets",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def load_user_sets(path: str = USER_SETS_DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Carrega todos os conjuntos de n√∫meros salvos pelo usu√°rio.\n    \"\"\"\n    init_user_sets_db(path)\n    user_sets: List[Dict[str, Any]] = []\n    try:\n        with sqlite3.connect(path, timeout=20.0) as conn:\n            cursor: sqlite3.Cursor = conn.cursor()\n            cursor.execute('SELECT id, name, date_generated, dez1, dez2, dez3, dez4, dez5, dez6, comparison_result, comparison_concurso FROM user_sets')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "delete_user_set",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def delete_user_set(set_id: int, path: str = USER_SETS_DB_PATH) -> bool:\n    \"\"\"\n    Deleta um conjunto de n√∫meros do usu√°rio pelo ID.\n    \"\"\"\n    try:\n        with sqlite3.connect(path, timeout=20.0) as conn:\n            cursor: sqlite3.Cursor = conn.cursor()\n            cursor.execute(\"DELETE FROM user_sets WHERE id = ?\", (set_id,))\n            conn.commit()\n            logging.info(f\"Conjunto de n√∫meros com ID {set_id} deletado.\")",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "compare_user_sets_with_latest_draw",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def compare_user_sets_with_latest_draw(user_sets_path: str = USER_SETS_DB_PATH, mega_sena_db_path: str = DB_PATH) -> List[Dict[str, Any]]:\n    \"\"\"\n    Compara todos os conjuntos de n√∫meros do usu√°rio com o √∫ltimo sorteio da Mega-Sena.\n    \"\"\"\n    latest_draw_data: Optional[Dict[str, Any]] = None\n    try:\n        latest_draw_api = fetch_lottery_data(\"megasena\", None)\n        latest_draw_data = {\n            'concurso': int(latest_draw_api['concurso']),\n            'dezenas': sorted(list(map(int, latest_draw_api['dezenas'])))",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "compare_numbers_with_latest_draw",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def compare_numbers_with_latest_draw(numbers: List[int], mega_sena_db_path: str = DB_PATH) -> Dict[str, Any]:\n    \"\"\"\n    Compara um √∫nico conjunto de n√∫meros com o √∫ltimo sorteio da Mega-Sena.\n    Retorna um dicion√°rio com o resultado da compara√ß√£o ou {} em caso de erro.\n    \"\"\"\n    if not numbers or len(numbers) != NUM_DEZENAS:\n        logging.error(\"N√∫mero de dezenas para compara√ß√£o inv√°lido.\")\n        return {}\n    latest_draw_data: Optional[Dict[str, Any]] = None\n    try:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "init_backtest_db",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def init_backtest_db(path: str = BACKTEST_DB_PATH) -> None:\n    \"\"\"\n    Inicializa a base de dados para armazenar os resultados do backtest,\n    criando a tabela 'backtest_results' se n√£o existir.\n    \"\"\"\n    try:\n        with sqlite3.connect(path, timeout=20.0) as conn:\n            cursor: sqlite3.Cursor = conn.cursor()\n            cursor.execute('''\n                CREATE TABLE IF NOT EXISTS backtest_results (",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_backtest",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def run_backtest(method: str) -> bool:\n    \"\"\"\n    Executa o backtest para um m√©todo de gera√ß√£o de n√∫meros e salva os resultados.\n    \"\"\"\n    init_backtest_db()\n    draws = load_all_draws()\n    if not draws:\n        logging.error('Base de dados vazia para backtest. Execute --update primeiro.')\n        return False\n    generated_numbers: Optional[List[int]] = []",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "run_backtest_multiple",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def run_backtest_multiple(method: str, times: int = 1) -> Dict[str, Any]:\n    \"\"\"\n    Executa o backtest m√∫ltiplas vezes para um m√©todo e retorna resumo consolidado.\n    Args:\n        method: M√©todo de gera√ß√£o ('alltime', 'lastyear', 'weighted')\n        times: N√∫mero de vezes a executar o backtest (padr√£o: 1)\n    Returns:\n        Dicion√°rio com resumo consolidado dos backtests\n    \"\"\"\n    if times < 1:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_backtest_summary",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def get_backtest_summary(method: str) -> Dict[str, Any]:\n    \"\"\"\n    Carrega os resultados do backtest para um m√©todo e retorna um resumo.\n    \"\"\"\n    summary = {\n        'method': method,\n        'numbers': [],\n        'total_draws': 0,\n        'matches': Counter()\n    }",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description='Mega-Sena Analyzer')\n    parser.add_argument('--update', action='store_true', help='Atualiza a base de dados local')\n    parser.add_argument('--alltime', action='store_true', help='Top 6 de todos os tempos')\n    parser.add_argument('--lastyear', action='store_true', help='Top 6 do √∫ltimo ano')\n    parser.add_argument('--stat', action='store_true', help='Conjunto estat√≠stico ponderado')\n    parser.add_argument('--backtest-insights', nargs='?', const='weighted', choices=['alltime', 'lastyear', 'weighted'], help='Gera n√∫meros usando hist√≥rico de backtest (op√ß√£o: alltime, lastyear, weighted)')\n    parser.add_argument('--db-path', type=str, help='Caminho personalizado para o banco de dados')\n    parser.add_argument('--plot', action='store_true', help='Visualizar frequ√™ncia dos n√∫meros')\n    parser.add_argument('--montecarlo', action='store_true', help='Simula√ß√£o de Monte Carlo')",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "CONFIG_AVAILABLE",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "CONFIG_AVAILABLE = False\nget_config = None\nget_db_path = None\nget_monte_carlo_simulations = None\nis_cache_enabled = None\nsetup_enhanced_logging = None\nget_logger = None\nlog_performance = None\nlog_analysis_result = None\ntry:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "get_config = None\nget_db_path = None\nget_monte_carlo_simulations = None\nis_cache_enabled = None\nsetup_enhanced_logging = None\nget_logger = None\nlog_performance = None\nlog_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_db_path",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "get_db_path = None\nget_monte_carlo_simulations = None\nis_cache_enabled = None\nsetup_enhanced_logging = None\nget_logger = None\nlog_performance = None\nlog_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled\n    from logging_config import setup_enhanced_logging, get_logger, log_performance, log_analysis_result",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_monte_carlo_simulations",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "get_monte_carlo_simulations = None\nis_cache_enabled = None\nsetup_enhanced_logging = None\nget_logger = None\nlog_performance = None\nlog_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled\n    from logging_config import setup_enhanced_logging, get_logger, log_performance, log_analysis_result\n    CONFIG_AVAILABLE = True",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "is_cache_enabled",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "is_cache_enabled = None\nsetup_enhanced_logging = None\nget_logger = None\nlog_performance = None\nlog_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled\n    from logging_config import setup_enhanced_logging, get_logger, log_performance, log_analysis_result\n    CONFIG_AVAILABLE = True\nexcept ImportError:",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "setup_enhanced_logging",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "setup_enhanced_logging = None\nget_logger = None\nlog_performance = None\nlog_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled\n    from logging_config import setup_enhanced_logging, get_logger, log_performance, log_analysis_result\n    CONFIG_AVAILABLE = True\nexcept ImportError:\n    CONFIG_AVAILABLE = False",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "get_logger = None\nlog_performance = None\nlog_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled\n    from logging_config import setup_enhanced_logging, get_logger, log_performance, log_analysis_result\n    CONFIG_AVAILABLE = True\nexcept ImportError:\n    CONFIG_AVAILABLE = False\n    logging.warning(\"Sistema de configura√ß√£o n√£o dispon√≠vel. Usando valores padr√£o.\")",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "log_performance",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "log_performance = None\nlog_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled\n    from logging_config import setup_enhanced_logging, get_logger, log_performance, log_analysis_result\n    CONFIG_AVAILABLE = True\nexcept ImportError:\n    CONFIG_AVAILABLE = False\n    logging.warning(\"Sistema de configura√ß√£o n√£o dispon√≠vel. Usando valores padr√£o.\")\n# Conditional imports for external libraries",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "log_analysis_result",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "log_analysis_result = None\ntry:\n    from config import get_config, get_db_path, get_monte_carlo_simulations, is_cache_enabled\n    from logging_config import setup_enhanced_logging, get_logger, log_performance, log_analysis_result\n    CONFIG_AVAILABLE = True\nexcept ImportError:\n    CONFIG_AVAILABLE = False\n    logging.warning(\"Sistema de configura√ß√£o n√£o dispon√≠vel. Usando valores padr√£o.\")\n# Conditional imports for external libraries\n# These are placed here to indicate they are optional if only core functionality is used.",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 5,
        "importPath": "mega_sena_app",
        "description": "mega_sena_app",
        "peekOfCode": "Draw = Tuple[datetime.date, Tuple[int, int, int, int, int, int]]\n# Cache para melhorar performance\n# Usamos lru_cache para um cache simples e robusto. invalidate_cache() limpa o cache.\nfrom functools import lru_cache\n# Mantemos get_db_hash para invalidar o cache quando o banco muda\ndef get_db_hash(path: str = DB_PATH) -> str:\n    \"\"\"Gera hash do arquivo de banco para invalidar cache quando necess√°rio\"\"\"\n    try:\n        with open(path, 'rb') as f:\n            return hashlib.md5(f.read()).hexdigest()",
        "detail": "mega_sena_app",
        "documentation": {}
    },
    {
        "label": "TestMegaSenaAnalyzer",
        "kind": 6,
        "importPath": "tests",
        "description": "tests",
        "peekOfCode": "class TestMegaSenaAnalyzer(unittest.TestCase):\n    \"\"\"Testes para o analisador da Mega-Sena\"\"\"\n    def setUp(self):\n        \"\"\"Configura√ß√£o inicial para os testes\"\"\"\n        if not MODULE_AVAILABLE:\n            self.skipTest(\"M√≥dulo mega_sena_app n√£o pode ser importado\")\n        # Dados de teste - usar datas mais recentes\n        self.sample_draws = [\n            (datetime.date.today() - datetime.timedelta(days=5), (1, 2, 3, 4, 5, 6)),\n            (datetime.date.today() - datetime.timedelta(days=10), (7, 8, 9, 10, 11, 12)),",
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "TestDatabaseOperations",
        "kind": 6,
        "importPath": "tests",
        "description": "tests",
        "peekOfCode": "class TestDatabaseOperations(unittest.TestCase):\n    \"\"\"Testes para opera√ß√µes de banco de dados\"\"\"\n    def setUp(self):\n        \"\"\"Configura√ß√£o inicial para testes de banco\"\"\"\n        if not MODULE_AVAILABLE:\n            self.skipTest(\"M√≥dulo mega_sena_app n√£o pode ser importado\")\n        # Criar banco tempor√°rio para testes\n        self.temp_db_file = tempfile.NamedTemporaryFile(delete=False)\n        self.temp_db_path = self.temp_db_file.name\n        self.temp_db_file.close()",
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "TestMathematicalFunctions",
        "kind": 6,
        "importPath": "tests",
        "description": "tests",
        "peekOfCode": "class TestMathematicalFunctions(unittest.TestCase):\n    \"\"\"Testes para fun√ß√µes matem√°ticas e estat√≠sticas\"\"\"\n    def test_edge_cases(self):\n        \"\"\"Testa casos extremos\"\"\"\n        if not MODULE_AVAILABLE:\n            self.skipTest(\"M√≥dulo mega_sena_app n√£o pode ser importado\")\n        # Lista vazia\n        empty_draws = []\n        if hasattr(mega_sena_app, 'get_most_frequent'):\n            result = mega_sena_app.get_most_frequent(empty_draws, k=6)",
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "tests",
        "description": "tests",
        "peekOfCode": "project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nsys.path.insert(0, project_root)\n# Tentar importar o m√≥dulo principal\ntry:\n    import mega_sena_app\n    MODULE_AVAILABLE = True\nexcept ImportError as e:\n    print(f\"Erro ao importar mega_sena_app: {e}\")\n    MODULE_AVAILABLE = False\n    mega_sena_app = None",
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "TestMegaSenaAnalyzer",
        "kind": 6,
        "importPath": "tests_fixed",
        "description": "tests_fixed",
        "peekOfCode": "class TestMegaSenaAnalyzer(unittest.TestCase):\n    \"\"\"Testes para o analisador da Mega-Sena\"\"\"\n    def setUp(self):\n        \"\"\"Configura√ß√£o inicial para os testes\"\"\"\n        if not MODULE_AVAILABLE:\n            self.skipTest(\"M√≥dulo mega_sena_app n√£o pode ser importado\")\n        # Dados de teste - usar datas mais recentes\n        self.sample_draws = [\n            (datetime.date.today() - datetime.timedelta(days=5), (1, 2, 3, 4, 5, 6)),\n            (datetime.date.today() - datetime.timedelta(days=10), (7, 8, 9, 10, 11, 12)),",
        "detail": "tests_fixed",
        "documentation": {}
    },
    {
        "label": "TestDatabaseOperations",
        "kind": 6,
        "importPath": "tests_fixed",
        "description": "tests_fixed",
        "peekOfCode": "class TestDatabaseOperations(unittest.TestCase):\n    \"\"\"Testes para opera√ß√µes de banco de dados\"\"\"\n    def setUp(self):\n        \"\"\"Configura√ß√£o inicial para testes de banco\"\"\"\n        if not MODULE_AVAILABLE:\n            self.skipTest(\"M√≥dulo mega_sena_app n√£o pode ser importado\")\n        # Criar banco tempor√°rio para testes\n        self.temp_db_file = tempfile.NamedTemporaryFile(delete=False)\n        self.temp_db_path = self.temp_db_file.name\n        self.temp_db_file.close()",
        "detail": "tests_fixed",
        "documentation": {}
    },
    {
        "label": "TestMathematicalFunctions",
        "kind": 6,
        "importPath": "tests_fixed",
        "description": "tests_fixed",
        "peekOfCode": "class TestMathematicalFunctions(unittest.TestCase):\n    \"\"\"Testes para fun√ß√µes matem√°ticas e estat√≠sticas\"\"\"\n    def test_edge_cases(self):\n        \"\"\"Testa casos extremos\"\"\"\n        if not MODULE_AVAILABLE:\n            self.skipTest(\"M√≥dulo mega_sena_app n√£o pode ser importado\")\n        # Lista vazia\n        empty_draws = []\n        if hasattr(mega_sena_app, 'get_most_frequent'):\n            result = mega_sena_app.get_most_frequent(empty_draws, k=6)",
        "detail": "tests_fixed",
        "documentation": {}
    },
    {
        "label": "fake_draws",
        "kind": 2,
        "importPath": "tmp_headless_export",
        "description": "tmp_headless_export",
        "peekOfCode": "def fake_draws():\n    return [(datetime.date(2025,1,1), [1,2,3,4,5,6]), (datetime.date(2025,1,8), [1,2,7,8,9,10])]\n# Monkeypatch load_all_draws\ngui.load_all_draws = lambda: fake_draws()\n# Create temp file for output\ntemp = tempfile.NamedTemporaryFile(delete=False, suffix='.csv')\npath = temp.name\ntemp.close()\nprint('Temp file path:', path)\n# Patch ask_on_main_thread to return our choices",
        "detail": "tmp_headless_export",
        "documentation": {}
    },
    {
        "label": "ask_override",
        "kind": 2,
        "importPath": "tmp_headless_export",
        "description": "tmp_headless_export",
        "peekOfCode": "def ask_override(func, *args, **kwargs):\n    name = getattr(func, '__name__', '')\n    if 'askstring' in name:\n        return 'frequencia'\n    if 'asksaveasfilename' in name:\n        return path\n    return func(*args, **kwargs)\n# Replace helper\ngui.ask_on_main_thread = ask_override\n# Trigger advanced export",
        "detail": "tmp_headless_export",
        "documentation": {}
    },
    {
        "label": "gui.load_all_draws",
        "kind": 5,
        "importPath": "tmp_headless_export",
        "description": "tmp_headless_export",
        "peekOfCode": "gui.load_all_draws = lambda: fake_draws()\n# Create temp file for output\ntemp = tempfile.NamedTemporaryFile(delete=False, suffix='.csv')\npath = temp.name\ntemp.close()\nprint('Temp file path:', path)\n# Patch ask_on_main_thread to return our choices\ndef ask_override(func, *args, **kwargs):\n    name = getattr(func, '__name__', '')\n    if 'askstring' in name:",
        "detail": "tmp_headless_export",
        "documentation": {}
    },
    {
        "label": "temp",
        "kind": 5,
        "importPath": "tmp_headless_export",
        "description": "tmp_headless_export",
        "peekOfCode": "temp = tempfile.NamedTemporaryFile(delete=False, suffix='.csv')\npath = temp.name\ntemp.close()\nprint('Temp file path:', path)\n# Patch ask_on_main_thread to return our choices\ndef ask_override(func, *args, **kwargs):\n    name = getattr(func, '__name__', '')\n    if 'askstring' in name:\n        return 'frequencia'\n    if 'asksaveasfilename' in name:",
        "detail": "tmp_headless_export",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tmp_headless_export",
        "description": "tmp_headless_export",
        "peekOfCode": "path = temp.name\ntemp.close()\nprint('Temp file path:', path)\n# Patch ask_on_main_thread to return our choices\ndef ask_override(func, *args, **kwargs):\n    name = getattr(func, '__name__', '')\n    if 'askstring' in name:\n        return 'frequencia'\n    if 'asksaveasfilename' in name:\n        return path",
        "detail": "tmp_headless_export",
        "documentation": {}
    },
    {
        "label": "gui.ask_on_main_thread",
        "kind": 5,
        "importPath": "tmp_headless_export",
        "description": "tmp_headless_export",
        "peekOfCode": "gui.ask_on_main_thread = ask_override\n# Trigger advanced export\ngui.export_data_gui(advanced=True)\n# Wait for background thread to finish\nfor _ in range(50):\n    import threading\n    alive = any(t.is_alive() and t.name != 'MainThread' for t in threading.enumerate())\n    if not alive:\n        break\n    time.sleep(0.1)",
        "detail": "tmp_headless_export",
        "documentation": {}
    },
    {
        "label": "DummyRoot",
        "kind": 6,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "class DummyRoot:\n    def after(self, ms, func, *args):\n        func(*args)\n    def config(self, **kwargs):\n        pass\nG.root = DummyRoot()\nG.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: print('progress start'), 'stop': lambda self: print('progress stop')})()\n# dummy interactive button\nclass DummyButton:",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "DummyButton",
        "kind": 6,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "class DummyButton:\n    def __init__(self): self.state = 'normal'\n    def config(self, **k): self.state = k.get('state', self.state)\nbtn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI functions use our temp DB\nG.load_all_draws = lambda: app.load_all_draws(path)\n# Run backtest GUI (synchronous)\nprint('Running backtest GUI...')",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "f = tempfile.NamedTemporaryFile(delete=False, suffix='.db')\npath = f.name\nf.close()\napp.init_db(path)\ntry:\n    app.set_db_path(path)\nexcept Exception:\n    app.DB_PATH = path\nwith app.open_db(path) as conn:\n    cur = conn.cursor()",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "path = f.name\nf.close()\napp.init_db(path)\ntry:\n    app.set_db_path(path)\nexcept Exception:\n    app.DB_PATH = path\nwith app.open_db(path) as conn:\n    cur = conn.cursor()\n    # Insert multiple draws",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "G.root",
        "kind": 5,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "G.root = DummyRoot()\nG.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: print('progress start'), 'stop': lambda self: print('progress stop')})()\n# dummy interactive button\nclass DummyButton:\n    def __init__(self): self.state = 'normal'\n    def config(self, **k): self.state = k.get('state', self.state)\nbtn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "G.status_bar",
        "kind": 5,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "G.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: print('progress start'), 'stop': lambda self: print('progress stop')})()\n# dummy interactive button\nclass DummyButton:\n    def __init__(self): self.state = 'normal'\n    def config(self, **k): self.state = k.get('state', self.state)\nbtn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI functions use our temp DB",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "G.progress_bar",
        "kind": 5,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "G.progress_bar = type('P', (), {'start': lambda self, x: print('progress start'), 'stop': lambda self: print('progress stop')})()\n# dummy interactive button\nclass DummyButton:\n    def __init__(self): self.state = 'normal'\n    def config(self, **k): self.state = k.get('state', self.state)\nbtn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI functions use our temp DB\nG.load_all_draws = lambda: app.load_all_draws(path)",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "btn",
        "kind": 5,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "btn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI functions use our temp DB\nG.load_all_draws = lambda: app.load_all_draws(path)\n# Run backtest GUI (synchronous)\nprint('Running backtest GUI...')\nG.run_backtest_gui('weighted')\nprint('Backtest GUI done; button state:', btn.state)\n# Run montecarlo analysis (asynchronous via run_in_thread)",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "G.load_all_draws",
        "kind": 5,
        "importPath": "tmp_headless_tests",
        "description": "tmp_headless_tests",
        "peekOfCode": "G.load_all_draws = lambda: app.load_all_draws(path)\n# Run backtest GUI (synchronous)\nprint('Running backtest GUI...')\nG.run_backtest_gui('weighted')\nprint('Backtest GUI done; button state:', btn.state)\n# Run montecarlo analysis (asynchronous via run_in_thread)\nprint('Running Monte Carlo via run_analysis_gui...')\nG.run_analysis_gui('montecarlo')\n# wait for background thread to finish\nfor _ in range(100):",
        "detail": "tmp_headless_tests",
        "documentation": {}
    },
    {
        "label": "StatusBar",
        "kind": 6,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "class StatusBar:\n    def __init__(self): self.text = ''\n    def config(self, **k): self.text = k.get('text', self.text)\nclass ProgressBar:\n    def __init__(self): self.running=False\n    def start(self, *_): self.running=True\n    def stop(self): self.running=False\nG.status_bar = StatusBar()\nG.progress_bar = ProgressBar()\n# Dummy interactive button",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "ProgressBar",
        "kind": 6,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "class ProgressBar:\n    def __init__(self): self.running=False\n    def start(self, *_): self.running=True\n    def stop(self): self.running=False\nG.status_bar = StatusBar()\nG.progress_bar = ProgressBar()\n# Dummy interactive button\nclass DummyButton:\n    def __init__(self): self.state='normal'\n    def config(self, **k): self.state = k.get('state', self.state)",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "DummyButton",
        "kind": 6,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "class DummyButton:\n    def __init__(self): self.state='normal'\n    def config(self, **k): self.state = k.get('state', self.state)\nbtn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI uses our temp DB for draw loading\nG.load_all_draws = lambda: app.load_all_draws(path)\n# We'll schedule the test sequence using root.after so mainloop runs on the main thread.\n# This avoids RuntimeError: main thread is not in main loop when worker threads call root.after.",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "run_export_then_next",
        "kind": 2,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "def run_export_then_next():\n    with patch('gui.simpledialog.askstring', return_value='frequencia'):\n        with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n            G.export_data_gui(advanced=True)\n    # wait for background threads to finish\n    root.after(50, check_export_completion)\ndef check_export_completion():\n    alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())\n    if alive:\n        root.after(50, check_export_completion)",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "check_export_completion",
        "kind": 2,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "def check_export_completion():\n    alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())\n    if alive:\n        root.after(50, check_export_completion)\n    else:\n        print('Export advanced: status=', G.status_bar.text)\n        root.after(0, run_backtest_then_next)\ndef run_backtest_then_next():\n    G.run_backtest_gui(method='weighted')\n    # run_backtest_gui schedules result display via root.after; give it time",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "run_backtest_then_next",
        "kind": 2,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "def run_backtest_then_next():\n    G.run_backtest_gui(method='weighted')\n    # run_backtest_gui schedules result display via root.after; give it time\n    root.after(200, check_backtest_completion)\ndef check_backtest_completion():\n    # backtest is generally synchronous but might have scheduled callbacks\n    print('Backtest done; status=', G.status_bar.text)\n    root.after(0, run_monte_then_finish)\ndef run_monte_then_finish():\n    G.run_analysis_gui('montecarlo')",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "check_backtest_completion",
        "kind": 2,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "def check_backtest_completion():\n    # backtest is generally synchronous but might have scheduled callbacks\n    print('Backtest done; status=', G.status_bar.text)\n    root.after(0, run_monte_then_finish)\ndef run_monte_then_finish():\n    G.run_analysis_gui('montecarlo')\n    root.after(50, check_monte_completion)\ndef check_monte_completion():\n    alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())\n    if alive:",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "run_monte_then_finish",
        "kind": 2,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "def run_monte_then_finish():\n    G.run_analysis_gui('montecarlo')\n    root.after(50, check_monte_completion)\ndef check_monte_completion():\n    alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())\n    if alive:\n        root.after(50, check_monte_completion)\n    else:\n        print('Monte Carlo: status=', G.status_bar.text)\n        # End of sequence",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "check_monte_completion",
        "kind": 2,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "def check_monte_completion():\n    alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())\n    if alive:\n        root.after(50, check_monte_completion)\n    else:\n        print('Monte Carlo: status=', G.status_bar.text)\n        # End of sequence\n        root.quit()\n# Start the sequence and enter mainloop so that root.after callbacks work.\nroot.after(0, run_export_then_next)",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "f = tempfile.NamedTemporaryFile(delete=False, suffix='.db')\npath = f.name\nf.close()\napp.init_db(path)\ntry:\n    app.set_db_path(path)\nexcept Exception:\n    app.DB_PATH = path\nwith app.open_db(path) as conn:\n    cur = conn.cursor()",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "path = f.name\nf.close()\napp.init_db(path)\ntry:\n    app.set_db_path(path)\nexcept Exception:\n    app.DB_PATH = path\nwith app.open_db(path) as conn:\n    cur = conn.cursor()\n    # Insert several sample draws",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "root = tk.Tk()\nroot.withdraw()\nG.root = root\n# Minimal status bar and progress bar objects\nclass StatusBar:\n    def __init__(self): self.text = ''\n    def config(self, **k): self.text = k.get('text', self.text)\nclass ProgressBar:\n    def __init__(self): self.running=False\n    def start(self, *_): self.running=True",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "G.root",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "G.root = root\n# Minimal status bar and progress bar objects\nclass StatusBar:\n    def __init__(self): self.text = ''\n    def config(self, **k): self.text = k.get('text', self.text)\nclass ProgressBar:\n    def __init__(self): self.running=False\n    def start(self, *_): self.running=True\n    def stop(self): self.running=False\nG.status_bar = StatusBar()",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "G.status_bar",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "G.status_bar = StatusBar()\nG.progress_bar = ProgressBar()\n# Dummy interactive button\nclass DummyButton:\n    def __init__(self): self.state='normal'\n    def config(self, **k): self.state = k.get('state', self.state)\nbtn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI uses our temp DB for draw loading",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "G.progress_bar",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "G.progress_bar = ProgressBar()\n# Dummy interactive button\nclass DummyButton:\n    def __init__(self): self.state='normal'\n    def config(self, **k): self.state = k.get('state', self.state)\nbtn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI uses our temp DB for draw loading\nG.load_all_draws = lambda: app.load_all_draws(path)",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "btn",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "btn = DummyButton()\nG.interactive_buttons.clear()\nG.interactive_buttons.append(btn)\n# Ensure GUI uses our temp DB for draw loading\nG.load_all_draws = lambda: app.load_all_draws(path)\n# We'll schedule the test sequence using root.after so mainloop runs on the main thread.\n# This avoids RuntimeError: main thread is not in main loop when worker threads call root.after.\ndef run_export_then_next():\n    with patch('gui.simpledialog.askstring', return_value='frequencia'):\n        with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "G.load_all_draws",
        "kind": 5,
        "importPath": "tmp_interactive_test",
        "description": "tmp_interactive_test",
        "peekOfCode": "G.load_all_draws = lambda: app.load_all_draws(path)\n# We'll schedule the test sequence using root.after so mainloop runs on the main thread.\n# This avoids RuntimeError: main thread is not in main loop when worker threads call root.after.\ndef run_export_then_next():\n    with patch('gui.simpledialog.askstring', return_value='frequencia'):\n        with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n            G.export_data_gui(advanced=True)\n    # wait for background threads to finish\n    root.after(50, check_export_completion)\ndef check_export_completion():",
        "detail": "tmp_interactive_test",
        "documentation": {}
    },
    {
        "label": "DummyRoot",
        "kind": 6,
        "importPath": "tmp_manual_export_run2",
        "description": "tmp_manual_export_run2",
        "peekOfCode": "class DummyRoot:\n    def after(self, ms, func, *args):\n        func(*args)\n    def config(self, **kwargs):\n        pass\nG.root = DummyRoot()\nG.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Ensure the GUI's load_all_draws uses our temp DB path (default parameter capture workaround)\nG.load_all_draws = lambda: app.load_all_draws(path)",
        "detail": "tmp_manual_export_run2",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "tmp_manual_export_run2",
        "description": "tmp_manual_export_run2",
        "peekOfCode": "f = tempfile.NamedTemporaryFile(delete=False, suffix='.db')\npath = f.name\nf.close()\napp.init_db(path)\n# Update global DB_PATH in the running app so export uses our temp DB\ntry:\n    app.set_db_path(path)\nexcept Exception:\n    # Backwards compatibility: fall back to assign global\n    app.DB_PATH = path",
        "detail": "tmp_manual_export_run2",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tmp_manual_export_run2",
        "description": "tmp_manual_export_run2",
        "peekOfCode": "path = f.name\nf.close()\napp.init_db(path)\n# Update global DB_PATH in the running app so export uses our temp DB\ntry:\n    app.set_db_path(path)\nexcept Exception:\n    # Backwards compatibility: fall back to assign global\n    app.DB_PATH = path\n# Insert sample draws using open_db context manager",
        "detail": "tmp_manual_export_run2",
        "documentation": {}
    },
    {
        "label": "G.root",
        "kind": 5,
        "importPath": "tmp_manual_export_run2",
        "description": "tmp_manual_export_run2",
        "peekOfCode": "G.root = DummyRoot()\nG.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Ensure the GUI's load_all_draws uses our temp DB path (default parameter capture workaround)\nG.load_all_draws = lambda: app.load_all_draws(path)\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):\n    with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n        # Call export_data_gui(advanced=True) and wait briefly\n        G.export_data_gui(advanced=True)",
        "detail": "tmp_manual_export_run2",
        "documentation": {}
    },
    {
        "label": "G.status_bar",
        "kind": 5,
        "importPath": "tmp_manual_export_run2",
        "description": "tmp_manual_export_run2",
        "peekOfCode": "G.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Ensure the GUI's load_all_draws uses our temp DB path (default parameter capture workaround)\nG.load_all_draws = lambda: app.load_all_draws(path)\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):\n    with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n        # Call export_data_gui(advanced=True) and wait briefly\n        G.export_data_gui(advanced=True)\n        # wait for background thread to finish",
        "detail": "tmp_manual_export_run2",
        "documentation": {}
    },
    {
        "label": "G.progress_bar",
        "kind": 5,
        "importPath": "tmp_manual_export_run2",
        "description": "tmp_manual_export_run2",
        "peekOfCode": "G.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Ensure the GUI's load_all_draws uses our temp DB path (default parameter capture workaround)\nG.load_all_draws = lambda: app.load_all_draws(path)\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):\n    with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n        # Call export_data_gui(advanced=True) and wait briefly\n        G.export_data_gui(advanced=True)\n        # wait for background thread to finish\n        for _ in range(50):",
        "detail": "tmp_manual_export_run2",
        "documentation": {}
    },
    {
        "label": "G.load_all_draws",
        "kind": 5,
        "importPath": "tmp_manual_export_run2",
        "description": "tmp_manual_export_run2",
        "peekOfCode": "G.load_all_draws = lambda: app.load_all_draws(path)\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):\n    with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n        # Call export_data_gui(advanced=True) and wait briefly\n        G.export_data_gui(advanced=True)\n        # wait for background thread to finish\n        for _ in range(50):\n            alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())\n            if not alive:",
        "detail": "tmp_manual_export_run2",
        "documentation": {}
    },
    {
        "label": "DummyRoot",
        "kind": 6,
        "importPath": "tmp_manual_export_test",
        "description": "tmp_manual_export_test",
        "peekOfCode": "class DummyRoot:\n    def after(self, ms, func, *args):\n        func(*args)\n    def config(self, **kwargs):\n        pass\nG.root = DummyRoot()\nG.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):",
        "detail": "tmp_manual_export_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "tmp_manual_export_test",
        "description": "tmp_manual_export_test",
        "peekOfCode": "f = tempfile.NamedTemporaryFile(delete=False, suffix='.db')\npath = f.name\nf.close()\napp.init_db(path)\n# Insert sample draws\nwith app.open_db(path) as conn:\n    cur = conn.cursor()\n    cur.execute(\"INSERT OR IGNORE INTO megasena(concurso, data, dez1,dez2,dez3,dez4,dez5,dez6) VALUES (?,?,?,?,?,?,?,?)\", (1, '2025-01-01',1,2,3,4,5,6))\n    conn.commit()\n# Dummy root to execute scheduled UI calls synchronously",
        "detail": "tmp_manual_export_test",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tmp_manual_export_test",
        "description": "tmp_manual_export_test",
        "peekOfCode": "path = f.name\nf.close()\napp.init_db(path)\n# Insert sample draws\nwith app.open_db(path) as conn:\n    cur = conn.cursor()\n    cur.execute(\"INSERT OR IGNORE INTO megasena(concurso, data, dez1,dez2,dez3,dez4,dez5,dez6) VALUES (?,?,?,?,?,?,?,?)\", (1, '2025-01-01',1,2,3,4,5,6))\n    conn.commit()\n# Dummy root to execute scheduled UI calls synchronously\nclass DummyRoot:",
        "detail": "tmp_manual_export_test",
        "documentation": {}
    },
    {
        "label": "G.root",
        "kind": 5,
        "importPath": "tmp_manual_export_test",
        "description": "tmp_manual_export_test",
        "peekOfCode": "G.root = DummyRoot()\nG.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):\n    with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n        # Call export_data_gui(advanced=True) and wait briefly\n        G.export_data_gui(advanced=True)\n        # wait for background thread to finish\n        for _ in range(20):",
        "detail": "tmp_manual_export_test",
        "documentation": {}
    },
    {
        "label": "G.status_bar",
        "kind": 5,
        "importPath": "tmp_manual_export_test",
        "description": "tmp_manual_export_test",
        "peekOfCode": "G.status_bar = type('S', (), {'config': lambda self, **k: None})()\nG.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):\n    with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n        # Call export_data_gui(advanced=True) and wait briefly\n        G.export_data_gui(advanced=True)\n        # wait for background thread to finish\n        for _ in range(20):\n            alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())",
        "detail": "tmp_manual_export_test",
        "documentation": {}
    },
    {
        "label": "G.progress_bar",
        "kind": 5,
        "importPath": "tmp_manual_export_test",
        "description": "tmp_manual_export_test",
        "peekOfCode": "G.progress_bar = type('P', (), {'start': lambda self, x: None, 'stop': lambda self: None})()\n# Patch dialogs\nwith patch('gui.simpledialog.askstring', return_value='frequencia'):\n    with patch('gui.filedialog.asksaveasfilename', return_value=tempfile.mktemp(suffix='.csv')):\n        # Call export_data_gui(advanced=True) and wait briefly\n        G.export_data_gui(advanced=True)\n        # wait for background thread to finish\n        for _ in range(20):\n            alive = any(t.is_alive() and t.name!='MainThread' for t in threading.enumerate())\n            if not alive:",
        "detail": "tmp_manual_export_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "tmp_test_unlink",
        "description": "tmp_test_unlink",
        "peekOfCode": "f = tempfile.NamedTemporaryFile(delete=False)\npath = f.name\nf.close()\nprint('Temp (sqlite raw):', path)\nconn = sqlite3.connect(path)\nconn.execute('CREATE TABLE IF NOT EXISTS test (id INTEGER)')\nconn.commit()\nconn.close()\ntry:\n    os.unlink(path)",
        "detail": "tmp_test_unlink",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tmp_test_unlink",
        "description": "tmp_test_unlink",
        "peekOfCode": "path = f.name\nf.close()\nprint('Temp (sqlite raw):', path)\nconn = sqlite3.connect(path)\nconn.execute('CREATE TABLE IF NOT EXISTS test (id INTEGER)')\nconn.commit()\nconn.close()\ntry:\n    os.unlink(path)\n    print('Removed OK (sqlite raw)')",
        "detail": "tmp_test_unlink",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "tmp_test_unlink",
        "description": "tmp_test_unlink",
        "peekOfCode": "conn = sqlite3.connect(path)\nconn.execute('CREATE TABLE IF NOT EXISTS test (id INTEGER)')\nconn.commit()\nconn.close()\ntry:\n    os.unlink(path)\n    print('Removed OK (sqlite raw)')\nexcept Exception as e:\n    print('Remove failed (sqlite raw):', e)\n    traceback.print_exc()",
        "detail": "tmp_test_unlink",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "tmp_test_unlink",
        "description": "tmp_test_unlink",
        "peekOfCode": "f = tempfile.NamedTemporaryFile(delete=False)\npath2 = f.name\nf.close()\nprint('Temp (init_db):', path2)\ninit_db(path2)\nprint('Init done')\nprint('Exists after init:', os.path.exists(path2))\ntry:\n    os.unlink(path2)\n    print('Removed OK (init_db)')",
        "detail": "tmp_test_unlink",
        "documentation": {}
    },
    {
        "label": "path2",
        "kind": 5,
        "importPath": "tmp_test_unlink",
        "description": "tmp_test_unlink",
        "peekOfCode": "path2 = f.name\nf.close()\nprint('Temp (init_db):', path2)\ninit_db(path2)\nprint('Init done')\nprint('Exists after init:', os.path.exists(path2))\ntry:\n    os.unlink(path2)\n    print('Removed OK (init_db)')\nexcept Exception as e:",
        "detail": "tmp_test_unlink",
        "documentation": {}
    },
    {
        "label": "DummyBar",
        "kind": 6,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "class DummyBar:\n    def __init__(self):\n        self.started = False\n        self.stopped = False\n    def start(self, val=0):\n        print('DummyBar.start called')\n        self.started = True\n    def stop(self):\n        print('DummyBar.stop called')\n        self.stopped = True",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "DummyLabel",
        "kind": 6,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "class DummyLabel:\n    def __init__(self):\n        self.text = ''\n    def config(self, **kwargs):\n        self.text = kwargs.get('text', self.text)\n        print('DummyLabel.config text=', self.text)\nclass DummyButton:\n    def __init__(self):\n        self.state = 'normal'\n    def config(self, **kwargs):",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "DummyButton",
        "kind": 6,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "class DummyButton:\n    def __init__(self):\n        self.state = 'normal'\n    def config(self, **kwargs):\n        if 'state' in kwargs:\n            self.state = kwargs['state']\n            print('DummyButton config state=', self.state)\nclass DummyRoot:\n    def __init__(self):\n        self.cursor = ''",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "DummyRoot",
        "kind": 6,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "class DummyRoot:\n    def __init__(self):\n        self.cursor = ''\n    def after(self, ms, func, *args):\n        # Call immediately for test determinism\n        func(*args)\n    def config(self, cursor=''):\n        self.cursor = cursor\n        print('DummyRoot.cursor=', self.cursor)\n# Inject dummies into module",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "G.root",
        "kind": 5,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "G.root = DummyRoot()\nG.progress_bar = DummyBar()\nG.status_bar = DummyLabel()\nbtns = [DummyButton() for _ in range(3)]\nG.interactive_buttons[:] = btns\n# Run an analysis that completes quickly\nG.run_analysis_gui('alltime')\n# Wait for worker thread to finish (simple wait)\nfor i in range(20):\n    # check if any thread other than main is alive that is not the interpreter thread",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "G.progress_bar",
        "kind": 5,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "G.progress_bar = DummyBar()\nG.status_bar = DummyLabel()\nbtns = [DummyButton() for _ in range(3)]\nG.interactive_buttons[:] = btns\n# Run an analysis that completes quickly\nG.run_analysis_gui('alltime')\n# Wait for worker thread to finish (simple wait)\nfor i in range(20):\n    # check if any thread other than main is alive that is not the interpreter thread\n    alive = any(t.is_alive() and t.name != 'MainThread' for t in threading.enumerate())",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "G.status_bar",
        "kind": 5,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "G.status_bar = DummyLabel()\nbtns = [DummyButton() for _ in range(3)]\nG.interactive_buttons[:] = btns\n# Run an analysis that completes quickly\nG.run_analysis_gui('alltime')\n# Wait for worker thread to finish (simple wait)\nfor i in range(20):\n    # check if any thread other than main is alive that is not the interpreter thread\n    alive = any(t.is_alive() and t.name != 'MainThread' for t in threading.enumerate())\n    if not alive:",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "btns",
        "kind": 5,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "btns = [DummyButton() for _ in range(3)]\nG.interactive_buttons[:] = btns\n# Run an analysis that completes quickly\nG.run_analysis_gui('alltime')\n# Wait for worker thread to finish (simple wait)\nfor i in range(20):\n    # check if any thread other than main is alive that is not the interpreter thread\n    alive = any(t.is_alive() and t.name != 'MainThread' for t in threading.enumerate())\n    if not alive:\n        break",
        "detail": "tmp_validate_gui",
        "documentation": {}
    },
    {
        "label": "G.interactive_buttons[:]",
        "kind": 5,
        "importPath": "tmp_validate_gui",
        "description": "tmp_validate_gui",
        "peekOfCode": "G.interactive_buttons[:] = btns\n# Run an analysis that completes quickly\nG.run_analysis_gui('alltime')\n# Wait for worker thread to finish (simple wait)\nfor i in range(20):\n    # check if any thread other than main is alive that is not the interpreter thread\n    alive = any(t.is_alive() and t.name != 'MainThread' for t in threading.enumerate())\n    if not alive:\n        break\n    time.sleep(0.1)",
        "detail": "tmp_validate_gui",
        "documentation": {}
    }
]